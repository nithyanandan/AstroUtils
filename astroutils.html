<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astroutils package &mdash; AstroUtils 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="AstroUtils 0.1.0 documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="astroutils-package">
<h1>astroutils package<a class="headerlink" href="#astroutils-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="astroutils.test.html">astroutils.test package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="astroutils.test.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="astroutils.test.html#module-astroutils.test.geometry_test">astroutils.test.geometry_test module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astroutils.test.html#module-astroutils.test.mathops_test">astroutils.test.mathops_test module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astroutils.test.html#module-astroutils.test.nonmathops_test">astroutils.test.nonmathops_test module</a></li>
<li class="toctree-l2"><a class="reference internal" href="astroutils.test.html#module-astroutils.test">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-astroutils.DSP_modules">
<span id="astroutils-dsp-modules-module"></span><h2>astroutils.DSP_modules module<a class="headerlink" href="#module-astroutils.DSP_modules" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.DSP_modules.FT1D">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">FT1D</code><span class="sig-paren">(</span><em>inp</em>, <em>ax=-1</em>, <em>use_real=False</em>, <em>shift=False</em>, <em>inverse=False</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#FT1D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.FT1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute FFT/IFFT using Numpy.</p>
<p>Inputs:</p>
<p>inp:    Input data (vector or array) to be Fourier transformed</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>ax:         Axis (scalar integer) over which FFT is performed. Default = -1</dt>
<dd>(last axis)</dd>
<dt>use_real:   [Boolean scalar] If True, compute only the positive frequency</dt>
<dd>components using the real part of the data</dd>
<dt>shift:      [Boolean] If True, shift the result to make the zeroth component</dt>
<dd>move to the center. Default=False</dd>
<dt>inverse:    [olean] If True, compute the inverse FFT. If False, compute the</dt>
<dd>FFT. Default=False</dd>
</dl>
<p>oututs:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.PFB_FIR_coeff">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">PFB_FIR_coeff</code><span class="sig-paren">(</span><em>nside</em>, <em>ntap</em>, <em>cutoff</em>, <em>nbits</em>, <em>window=('kaiser'</em>, <em>5)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#PFB_FIR_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.PFB_FIR_coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.PFB_empirical">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">PFB_empirical</code><span class="sig-paren">(</span><em>nchan</em>, <em>bank_nchan</em>, <em>rise_frac_half_max</em>, <em>fall_frac_half_max</em>, <em>log_fall_rise=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#PFB_empirical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.PFB_empirical" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a polyphase filter bank from empirical models.</p>
<p>Inputs:</p>
<p>nchan         [scalar] total number of samples in the output</p>
<dl class="docutils">
<dt>bank_nchan    [scalar] number of channels in each filter bank. bank_nchan</dt>
<dd>must be less than nchan</dd>
<dt>rise_frac_half_max</dt>
<dd>[scalar] fraction of bank_nchan in which the function rises 
from half-maximum to maximum value</dd>
<dt>fall_frac_half_max</dt>
<dd>[scalar] fraction of bank_nchan in which the function falls 
from maximum to half-maximum value</dd>
<dt>log_fall_rise [boolean] flag indicating if the rise and fall between maximum</dt>
<dd>and half-maximum values occur in logarithmic or linear
intervals. if True, log scale is used (default), otherwise a 
linear scale is used.</dd>
<dt>verbose       [boolean] If True (default), prints progress and diagnostic </dt>
<dd>messages. If False, suppress printing such messages.</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.PFB_shape">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">PFB_shape</code><span class="sig-paren">(</span><em>coeffs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#PFB_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.PFB_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.XC">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">XC</code><span class="sig-paren">(</span><em>inp1</em>, <em>inp2=None</em>, <em>pow2=False</em>, <em>shift=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#XC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.XC" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross-correlate two sequences.</p>
<p>Inputs:</p>
<p>inp1:    [list or numpy array] First sequence.</p>
<dl class="docutils">
<dt>inp2:    [list or numpy array] If not given, auto-correlation of inp1 is</dt>
<dd>returned.</dd>
<dt>pow2     [boolean] If set to True, will pad the results of the correlation </dt>
<dd>with zeros so the length of the correlated sequence is equal to the
next power of 2. If set to False, the correlated sequence is just 
padded with one sample of value 0. Default = False</dd>
<dt>shift:   [Boolean] If True, shift the correlated product such that it is </dt>
<dd>represented in FFT format. i.e., the first sample corresponds to
zero lag followed by positive lags. The second half corresponds to
negative lags. Default = True</dd>
<dt>Output:  The correlation of input sequences inp1 and inp2. The output is of </dt>
<dd>length len(inp1)+len(inp2)-1 zero padded to the nearest power of 2 
(if pow2 is True) or zero padded by one sample (if pow2 is False)
and shifted to be identical to a Fourier transform based estimate.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.apply_PFB_filter">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">apply_PFB_filter</code><span class="sig-paren">(</span><em>inp</em>, <em>nside</em>, <em>ntap</em>, <em>coeff=None</em>, <em>cutoff=None</em>, <em>nbits=None</em>, <em>window=('kaiser'</em>, <em>5)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#apply_PFB_filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.apply_PFB_filter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.discretize">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">discretize</code><span class="sig-paren">(</span><em>inp</em>, <em>nbits=None</em>, <em>nlevels=None</em>, <em>inprange=None</em>, <em>mode='floor'</em>, <em>discrete_out=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#discretize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretize the input sequence either through truncation or rounding to the
nearest levels</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inp         [numpy array] Input sequence as a vector or array, could also be</dt>
<dd>complex</dd>
<dt>nbits       [scalar integer] Number of bits. Must be positive. Number of </dt>
<dd>levels will be 2**nbits. This takes precedence over nlevels if
both are specified.</dd>
<dt>nlevels     [scalar integer] Number of levels. Must be positive. Will be used</dt>
<dd>only when nbits is not set.</dd>
<dt>inprange    [2-element list] Consists of min and max bounds for the data. The</dt>
<dd>data will be clipped outside this range. If set to None
(default), min and max of the data will be used</dd>
<dt>mode        [string] determines if the nearest neighbour is determined by </dt>
<dd>truncation to the next lower level or by round to the nearest 
level. mode can be set to &#8216;floor&#8217; or &#8216;truncate&#8217; for truncation.
It must be set to &#8216;round&#8217; or &#8216;nearest&#8217; for rounding to the 
nearest level. Default = None (applies truncation).</dd>
<dt>discrete_out</dt>
<dd>[boolean] If set to True, return the output in discrete levels. 
If False, output is scaled back to the input scale. Default is
True.</dd>
</dl>
<p>verbose     [boolean] If set to True, print progress and diagnostic messages</p>
<p>Outputs:</p>
<dl class="docutils">
<dt>inpmod      [numpy array] Discretized array same shape as input array. If </dt>
<dd>discrete_out is set to True, inpmod is given in discrete 
integer levels. If discrete_out is False, inpmod is given in
the scale of the input corresponding to discrete integer levels.
If input is complex, real and imaginary parts are separately 
discretized.</dd>
</dl>
<p>inpmin      [scalar] Lower bound on the data range used in discretization</p>
<p>interval    [scalar] Resolution between levels</p>
<p>Tuple consisting of discretized sequence (inpmod), minimum value determined
from original sequence or specified range (inpmin), and resolution between
levels (interval). If discrete_out is True, the rescaled output is given by 
inpmin + interval * inpmod when the input sequence is real and 
inpmin * (1+1j) + interval * inpmod when it is complex. When discrete_out is
False, the discretized values scaled to integer values are given by 
(inpmod - inpmin*(1+1j))/interval when the input is complex and 
(inpmod - inpmin)/interval when it is real.</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.downsampler">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">downsampler</code><span class="sig-paren">(</span><em>inp</em>, <em>factor</em>, <em>axis=-1</em>, <em>verbose=True</em>, <em>method='interp'</em>, <em>kind='linear'</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#downsampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.downsampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to downsample a given input sequence along a specific dimension 
where the input could be multi-dimensional (up to 8 dimensions)</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inp           [Numpy array] array which has to be downsampled. Cannot have</dt>
<dd>more than 8 dimensions</dd>
<dt>factor        [scalar] downsampling factor. positive integer or floating</dt>
<dd>point number greater than or equal to unity. If an integer, 
output is simply a sampled subset of the input. If not an 
integer, downsampling is obtained by interpolation.</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>axis          [scalar] Integer specifying the axis along which the array is</dt>
<dd>to be downsampled. Default = -1, the last axis.</dd>
<dt>verbose       [Boolean] If set to True, will print progress and/or</dt>
<dd>diagnostic messages. If False, will suppress printing such
messages. Default = True</dd>
<dt>method        [string] Specifies the method for resampling. Accepted values</dt>
<dd>are &#8216;FFT&#8217; and &#8216;interp&#8217; (default) for FFT-based and 
interpolation based techniques respectively. If method chosen
is &#8216;interp&#8217; then value in input keyword kind determines the
the kind of interpolation.</dd>
<dt>kind          [string] Spcifies the kind of interpolation. Applies only if </dt>
<dd>value of keyword input method is set to &#8216;interp&#8217;. This is 
used only if factor is not an integer thus requiring 
interpolation. Accepted values are &#8216;linear&#8217;, &#8216;quadratic&#8217; and 
&#8216;cubic&#8217;. Default = &#8216;linear&#8217;</dd>
<dt>fill_value    [scalar] Value to fill locations outside the index range of </dt>
<dd>input array. Default = NaN</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.fft_filter">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">fft_filter</code><span class="sig-paren">(</span><em>inp</em>, <em>axis=None</em>, <em>wts=None</em>, <em>width=None</em>, <em>passband='low'</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#fft_filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the input data using a low or high pass filter in frequency domain 
along an axis</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inp         [Numpy array] input data which has to be filtered across a given </dt>
<dd>axis</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>axis        Axis (scalar integer) over which FFT is performed. Default = None</dt>
<dd>(last axis). Any negative value or values exceeding the number of
axes in the input data will be reset to use the last axis.</dd>
<dt>wts         [Numpy array] frequency window of weights. Should either have </dt>
<dd>same shape as inp or have number of elements equal to the number
of elements in input data along specified axis. Default = None.
If not set, then it will be set to a rectangular window of width
specified in width (see below) and will be applied as a filter
identically to the entire data along the specified axis. The wts
should correspond to frequency domain wts that would have been 
obtained after fftshift. For instance, a low pass filter weights
should be dominant around the middle of the sequence while a high
pass filter weights would be concentrated at the beginning and 
end of the sequence.</dd>
<dt>width       [scalar] Width of the frequency window as a fraction of the </dt>
<dd>bandwidth. Has to be positive. Default is None. If width is None,
wts should be set. One and only one among wts and width should be 
set.</dd>
<dt>passband    [string scalar] String specifying the passband (&#8216;low&#8217; or &#8216;high&#8217;)</dt>
<dd>to be used. Default = &#8216;low&#8217;</dd>
<dt>verbose     [boolean] If set to True (default), print messages indicating</dt>
<dd>progress</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.filter_">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">filter_</code><span class="sig-paren">(</span><em>inp</em>, <em>wts=None</em>, <em>width=None</em>, <em>passband='low'</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#filter_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.filter_" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the input data using a low or high pass filter in frequency domain 
along an axis</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inp         [Numpy vector or array] M x N numpy array which has to be </dt>
<dd>filtered across columns.</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>wts         [Numpy vector] 1 x P or M x P array which will be used as the </dt>
<dd>frequency window of weights. P &lt;= N. Zeroth frequency of the 
weights should equal unity, otherwise the weights will be 
scaled accordingly. Default = None. If not set, then it will be 
set to a rectangular window of width specified in width
(see below) and will be applied as a filter identically to all
rows</dd>
<dt>width       [scalar] Width of the frequency window as a fraction of the </dt>
<dd>bandwidth (or equivalently N). Has to be positive. Default
is None. If width is None, wts should be set. One and only one
among wts and width should be set.</dd>
<dt>passband    [string scalar] String specifying the passband (&#8216;low&#8217; or &#8216;high&#8217;)</dt>
<dd>to be used. Default = &#8216;low&#8217;</dd>
<dt>verbose     [boolean] If set to True (default), print messages indicating</dt>
<dd>progress</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.pfbshape">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">pfbshape</code><span class="sig-paren">(</span><em>freq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#pfbshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.pfbshape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.rfft_append">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">rfft_append</code><span class="sig-paren">(</span><em>inp</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#rfft_append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.rfft_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the negative frequency left out by numpy.rfft()
and append in the right order to the output from numpy.rfft().</p>
<p>Input:</p>
<dl class="docutils">
<dt>inp       Input data of any dimensions to which negative frequency </dt>
<dd>components have to be appended.</dd>
</dl>
<p>Keyword Input:</p>
<dl class="docutils">
<dt>axis      [scalar] Axis along which negative frequency components</dt>
<dd>are to be appended. It has to be a scalar in the range
0 to Ndim-1 where Ndim is the number of axes in the data.</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.rfftfreq_append">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">rfftfreq_append</code><span class="sig-paren">(</span><em>rfft_freqs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#rfftfreq_append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.rfftfreq_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the negative frequencies for the output of numpy.rfftfreq() and
rearrange the frequencies in the correct order.</p>
<p>Input:</p>
<p>rfft_freqs      [Vector] Positive frequencies</p>
<p>Output:</p>
<p>Positive and negative frequencies computed from numpy.rfftfreq() made equal
to the output of numpy.fftfreq()
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.shaping">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">shaping</code><span class="sig-paren">(</span><em>N_samples</em>, <em>fraction=1.0</em>, <em>shape='rect'</em>, <em>area_normalize=False</em>, <em>peak=None</em>, <em>verbose=True</em>, <em>centering=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#shaping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.shaping" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to produce sequences which can be used as shaping windows for other
sequences.</p>
<p>Inputs:</p>
<p>N_samples    [Integer] Number of samples in the sequence. Should be positive</p>
<p>Keyword inputs:</p>
<dl class="docutils">
<dt>fraction     [Float] Fraction of N_samples outside of which the sequence is </dt>
<dd>zero-padded. The fraction of N_samples is where the shaped 
sequence is actually generated. For fraction less than unity,
the zero padding comes about symmetrically at the edges.</dd>
<dt>shape        [string] Shape type. Currently allowed values are &#8216;rect&#8217;, &#8216;bhw&#8217;</dt>
<dd>and &#8216;bnw&#8217; for rectangular, Blackman-Harris and Blackman-Nuttall
windows respectively</dd>
<dt>area_normalize</dt>
<dd>[Boolean] True mean re-normalize the sequence to have unit
area. False means no re-normalization is performed. Cannot be
set simulataneously if peak is set.</dd>
<dt>peak         [Float] If set, rescale the sequence so the peak is set to the</dt>
<dd>specified value.</dd>
</dl>
<p>verbose      [Boolean] If set, print progress and/or diagnostic messages.</p>
<p>Output:</p>
<dl class="docutils">
<dt>samples      [Numpy array] Sequence containing the required shape and zero</dt>
<dd>padding if fraction &lt; 1.0</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.sinewave">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">sinewave</code><span class="sig-paren">(</span><em>freq</em>, <em>tlen=8192</em>, <em>clock_freq=655.36</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#sinewave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.sinewave" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.smooth">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">smooth</code><span class="sig-paren">(</span><em>inp</em>, <em>wts=None</em>, <em>width=None</em>, <em>stat='mean'</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#smooth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothen the input data using a moving average or median window along an
axis</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inp         [Numpy vector or array] M x N numpy array which has to be </dt>
<dd>smoothed across columns.</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>wts         [Numpy vector] 1 x P array which will be used as the window of</dt>
<dd>weights in case of a moving average. Will not be used if a 
median is used in place of mean. P &lt;= N. Sum of the weights
should equal unity, otherwise the weights will be accordingly
scaled. Default = None. If not set, then it will be set to a 
rectangular window of width specified in width (see below)</dd>
<dt>width       [scalar] Width of the moving window. Has to be positive. Default</dt>
<dd>is None. If width is None, wts should be set. One and only one
among wts and width should be set.</dd>
<dt>stat        [string scalar] String specifying the statistic (&#8216;mean&#8217; or</dt>
<dd>&#8216;median&#8217;) to be used. Default = &#8216;mean&#8217;</dd>
<dt>verbose     [boolean] If set to True (default), print messages indicating</dt>
<dd>progress</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.spectax">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">spectax</code><span class="sig-paren">(</span><em>length</em>, <em>resolution=1.0</em>, <em>shift=True</em>, <em>use_real=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#spectax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.spectax" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the spectral axis after a Fourier Transform</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>length     [Scalar] Positive integer specifying the length of sequence which is</dt>
<dd>to be Fourier transformed</dd>
<dt>resolution [Scalar] Positive value for resolution in the sequence before</dt>
<dd>Fourier Transform</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>use_real   [Boolean] If true, the input sequence is assumed to consist only</dt>
<dd>of real values and the spectral axis is computed accordingly. 
Default = False</dd>
<dt>shift      [Boolean] If true, the spectral axis values are shifted </dt>
<dd>cooresponding to a fftshift. Default = True</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.spectral_axis">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">spectral_axis</code><span class="sig-paren">(</span><em>length</em>, <em>delx=1.0</em>, <em>shift=False</em>, <em>use_real=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#spectral_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.spectral_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute spectral axis in the FFT</p>
<p>Inputs:</p>
<p>length:    Length of vector to be Fourier transformed</p>
<p>Keyword Inputs:</p>
<p>delx:        x-axis interval, used only in case of 1D inp. Default = 1.0</p>
<p>shift:       [Boolean scalar] True =&gt; Shift to center of frequencies</p>
<dl class="docutils">
<dt>use_real:    [Boolean scalar] True =&gt; Compute only positive frequencies using</dt>
<dd>numpy.fft.rfftfreq()</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.upsampler">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">upsampler</code><span class="sig-paren">(</span><em>inp</em>, <em>factor</em>, <em>axis=-1</em>, <em>verbose=True</em>, <em>kind='linear'</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#upsampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.upsampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to upsample a given input sequence along a specific dimension 
where the input could be multi-dimensional (up to 8 dimensions)</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inp           [Numpy array] array which has to be upsampled. Cannot have</dt>
<dd>more than 8 dimensions</dd>
<dt>factor        [scalar] upsampling factor. positive integer or floating</dt>
<dd>point number greater than or equal to unity. Upsampling is
obtained by interpolation.</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>axis          [scalar] Integer specifying the axis along which the array is</dt>
<dd>to be upsampled. Default = -1, the last axis.</dd>
<dt>verbose       [Boolean] If set to True, will print progress and/or</dt>
<dd>diagnostic messages. If False, will suppress printing such
messages. Default = True</dd>
<dt>kind          [string] Spcifies the kind of interpolation. Accepted values</dt>
<dd>are &#8216;linear&#8217;, &#8216;quadratic&#8217; and &#8216;cubic&#8217;. Default = &#8216;linear&#8217;</dd>
<dt>fill_value    [scalar] Value to fill locations outside the index range of </dt>
<dd>input array. Default = NaN</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.window_N2width">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">window_N2width</code><span class="sig-paren">(</span><em>n_window=None</em>, <em>shape='rect'</em>, <em>area_normalize=True</em>, <em>power_normalize=False</em>, <em>fftpow=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#window_N2width"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.window_N2width" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine effective width of a window as a fraction of the total width</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>n_window  [int] Number of samples in the window function. Default = None sets</dt>
<dd>it to 1000000</dd>
<dt>shape     [string] Specifies window shape. Accepted values are &#8216;rect&#8217; </dt>
<dd>(rectangular, default), &#8216;bnw&#8217; (Blackman-Nuttall) and &#8216;bhw&#8217; 
(Blackman-Harris)</dd>
<dt>area_normalize</dt>
<dd>[Boolean] True gives fractional width relative to a 
rectangular by computing area under window. One and only one 
of area_normalize or power_normalize can bet set</dd>
<dt>power_normalize</dt>
<dd>[Boolean] True gives fractional width relative to a 
rectangular by computing power under window. One and only one 
of area_normalize or power_normalize can bet set</dd>
<dt>fftpow    [scalar] The FFT of the window will be raised to this power.</dt>
<dd>Must be positive. Default = 1.0</dd>
</dl>
<p>Output:</p>
<p>frac_width is a fraction of the total number of samples. Thus the effective
width of the window function is frac_width * n_window. For instance, 
frac_width = 1 for shape = &#8216;rect&#8217;.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.window_fftpow">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">window_fftpow</code><span class="sig-paren">(</span><em>N_window</em>, <em>shape='rect'</em>, <em>pad_width=0</em>, <em>pad_value=0.0</em>, <em>fftpow=1.0</em>, <em>area_normalize=False</em>, <em>peak=None</em>, <em>power_normalize=False</em>, <em>verbose=True</em>, <em>centering=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#window_fftpow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.window_fftpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to produce window functions including ability to raise the FFT to a
given power</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>N_window     [Integer] Number of samples in the actual window. Should be</dt>
<dd>positive</dd>
</dl>
<p>Keyword inputs:</p>
<dl class="docutils">
<dt>shape        [string] Shape type. Currently allowed values are &#8216;rect&#8217;,</dt>
<dd>&#8216;bnw&#8217; and &#8216;bhw&#8217; for rectangular, Blackman-Nuttall and 
Blackman-Harris windows respectively</dd>
<dt>pad_width    [scalar integer] Number of padding samples. it has to be </dt>
<dd>non-negative. Padding values are provided in pad_values.</dd>
<dt>fftpow       [scalar] The FFT of the window will be raised to this power.</dt>
<dd>Must be positive. Default = 1.0</dd>
<dt>area_normalize</dt>
<dd>[Boolean] True means re-normalize the window to have unit
area. False means no re-normalization is performed. Cannot be
set simulataneously if peak or power_normalize is set.</dd>
<dt>peak         [Float] If set, rescale the window so the peak is set to the</dt>
<dd>specified value. Only one of peak, area_normalize or 
power_normalize can be set</dd>
<dt>power_normalize</dt>
<dd>[Boolean] True means re-normalize the window to have unit
power. False means no re-normalization is performed. Cannot be
set simulataneously if peak or area_normalize is set.</dd>
</dl>
<p>verbose      [Boolean] If set, print progress and/or diagnostic messages.</p>
<dl class="docutils">
<dt>centering    [Boolean] If set to True, centers the window with close to </dt>
<dd>symmetric on either side. If False, padding is done on the 
right side. Default = True</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>window       [Numpy array] window containing the required shape and padding</dt>
<dd>if pad_width &gt; 0</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.DSP_modules.windowing">
<code class="descclassname">astroutils.DSP_modules.</code><code class="descname">windowing</code><span class="sig-paren">(</span><em>N_window</em>, <em>shape='rect'</em>, <em>pad_width=0</em>, <em>pad_value=0.0</em>, <em>area_normalize=False</em>, <em>peak=None</em>, <em>power_normalize=False</em>, <em>verbose=True</em>, <em>centering=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/DSP_modules.html#windowing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.DSP_modules.windowing" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to produce sequences which can be used as shaping windows for other
sequences.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>N_window     [Integer] Number of samples in the actual window. Should be</dt>
<dd>positive</dd>
</dl>
<p>Keyword inputs:</p>
<dl class="docutils">
<dt>shape        [string] Shape type. Currently allowed values are &#8216;rect&#8217;,</dt>
<dd>&#8216;bnw&#8217; and &#8216;bhw&#8217; for rectangular, Blackman-Nuttall and 
Blackman-Harris windows respectively</dd>
<dt>pad_width    [scalar integer] Number of padding samples. it has to be </dt>
<dd>non-negative. Padding values are provided in pad_values.</dd>
<dt>area_normalize</dt>
<dd>[Boolean] True means re-normalize the window to have unit
area. False means no re-normalization is performed. Cannot be
set simulataneously if peak or power_normalize is set.</dd>
<dt>peak         [Float] If set, rescale the window so the peak is set to the</dt>
<dd>specified value. Only one of peak, area_normalize or 
power_normalize can be set</dd>
<dt>power_normalize</dt>
<dd>[Boolean] True means re-normalize the window to have unit
power. False means no re-normalization is performed. Cannot be
set simulataneously if peak or area_normalize is set.</dd>
</dl>
<p>verbose      [Boolean] If set, print progress and/or diagnostic messages.</p>
<dl class="docutils">
<dt>centering    [Boolean] If set to True, centers the window with close to </dt>
<dd>symmetric on either side. If False, padding is done on the 
right side. Default = True</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>window       [Numpy array] window containing the required shape and padding</dt>
<dd>if pad_width &gt; 0</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-astroutils.MPI_modules">
<span id="astroutils-mpi-modules-module"></span><h2>astroutils.MPI_modules module<a class="headerlink" href="#module-astroutils.MPI_modules" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astroutils.MPI_modules.Counter">
<em class="property">class </em><code class="descclassname">astroutils.MPI_modules.</code><code class="descname">Counter</code><span class="sig-paren">(</span><em>comm</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/MPI_modules.html#Counter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.MPI_modules.Counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="astroutils.MPI_modules.Counter.free">
<code class="descname">free</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/MPI_modules.html#Counter.free"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.MPI_modules.Counter.free" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="astroutils.MPI_modules.Counter.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/MPI_modules.html#Counter.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.MPI_modules.Counter.next" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-astroutils.catalog">
<span id="astroutils-catalog-module"></span><h2>astroutils.catalog module<a class="headerlink" href="#module-astroutils.catalog" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astroutils.catalog.SkyModel">
<em class="property">class </em><code class="descclassname">astroutils.catalog.</code><code class="descname">SkyModel</code><span class="sig-paren">(</span><em>init_file=None</em>, <em>init_parms=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/catalog.html#SkyModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.catalog.SkyModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Class to manage sky model information.</p>
<p>Attributes:</p>
<dl class="docutils">
<dt>name           [scalar or vector] Name of the catalog. If scalar, will be </dt>
<dd>used for all sources in the sky model. If vector, will be 
used for corresponding object. If vector, size must equal 
the number of objects.</dd>
<dt>frequency      [scalar or vector] Frequency range for which sky model is</dt>
<dd>applicable. Units in Hz.</dd>
<dt>location       [numpy array or list of lists] Positions of the sources in </dt>
<dd>sky model. Each position is specified as a row (numpy array)
or a 2-element list which is input as a list of lists for all
the sources in the sky model</dd>
<dt>spec_type      [string] specifies the flux variation along the spectral </dt>
<dd>axis. Allowed values are &#8216;func&#8217; and &#8216;spectrum&#8217;. If set to 
&#8216;func&#8217;, values under spec_parms are applicable. If set to 
&#8216;spectrum&#8217;, values under key &#8216;spectrum&#8217; are applicable.</dd>
<dt>spec_parms     [dictionary] specifies spectral parameters applicable for </dt>
<dd><p class="first">different spectral types. Only applicable if spec_type is 
set to &#8216;func&#8217;. It contains values in the following
keys:
&#8216;name&#8217;   [string] Specifies name of the functional variation</p>
<blockquote>
<div>of spectrum. Applicable when spec_type is set to 
&#8216;func&#8217;. Allowed values are &#8216;random&#8217;, &#8216;monotone&#8217;, 
&#8216;power-law&#8217;, and &#8216;tanh&#8217;. Default=&#8217;power-law&#8217; 
(with power law index set to 0). See member 
functions for these function definitions.</div></blockquote>
<dl class="last docutils">
<dt>&#8216;power-law-index&#8217; </dt>
<dd>[scalar numpy vector or list] Power law index for 
each object (flux ~ freq^power_law_index). Will be 
specified and applicable when value in key &#8216;name&#8217; 
is set to &#8216;power-law&#8217;. Same size as the number of 
object locations.</dd>
<dt>&#8216;freq-ref&#8217;</dt>
<dd>[scalar or numpy array or list] Reference or pivot
frequency as applicable. If a scalar, it is 
identical at all object locations. If a list or 
numpy array it must of size equal to the number of
objects, one value at each location. If
value under key &#8216;name&#8217; is set to &#8216;power-law&#8217;, this
specifies the reference frequency at which the flux
density is specified under key &#8216;flux-scale&#8217;. If 
value under key &#8216;name&#8217; is &#8216;monotone&#8217;, this specifies
the frequency at which the spectrum of the object 
contains a spike and zero elsewhere. If value under
key &#8216;name&#8217; is &#8216;tanh&#8217;, this specifies the frequency 
at which the spectrum is mid-way between min and 
max of the tanh function. This is not applicable 
when value under key &#8216;name&#8217; is set to &#8216;random&#8217; or 
&#8216;flat&#8217;.</dd>
<dt>&#8216;flux-scale&#8217; </dt>
<dd>[scalar or numpy array] Flux scale of the flux 
densities at object locations. If a scalar, it is
common for all object locations. If it is a vector, 
it has a size equal to the number of object 
locations, one value for each object location. If 
value in &#8216;name&#8217; is set to &#8216;power-law&#8217;, this refers 
to the flux density scale at the reference frequency
specified under key &#8216;freq-ref&#8217;. If value under key 
&#8216;name&#8217; is &#8216;tanh&#8217;, the flux density scale is half of
the value specified under this key.</dd>
<dt>&#8216;flux-offset&#8217;</dt>
<dd>[numpy vector] Flux density offset applicable after
applying the flux scale. Same units as the flux 
scale. If a scalar, it is common for all object 
locations. If it is a vector, it has a size equal 
to the number of object locations, one value 
for each object location. When value under the key
&#8216;name&#8217; is set to &#8216;random&#8217;, this amounts to setting
a mean flux density along the spectral axis.</dd>
<dt>&#8216;z-width&#8217;</dt>
<dd>[numpy vector] Characteristic redshift full-wdith
in the definition of tanh expression applicable to
global EoR signal.</dd>
</dl>
</dd>
<dt>spectrum       [numpy array] Spectrum of the catalog. Will be applicable </dt>
<dd>if attribute spec_type is set to &#8216;spectrum&#8217; or if spectrum
was computed using the member function. It will be of shape
nsrc x nchan</dd>
<dt>src_shape      [3-column numpy array or list of 3-element lists] source </dt>
<dd>shape specified by major axis FWHM (first column), minor axis 
FWHM (second column), and position angle (third column). The 
major and minor axes and position angle are stored in degrees. 
The number of rows must match the number of sources. Position 
angle is in degrees east of north (same convention as local
azimuth)</dd>
<dt>epoch          [string] Epoch appropriate for the coordinate system. Default</dt>
<dd>is &#8216;J2000&#8217;</dd>
<dt>coords         [string] Coordinate system used for the source positions in </dt>
<dd>the sky model. Currently accepted values are &#8216;radec&#8217; (RA-Dec)</dd>
</dl>
<p>Member Functions:</p>
<p>__init__()     Initialize an instance of class SkyModel</p>
<dl class="docutils">
<dt>match()        Match the source positions in an instance of class </dt>
<dd>SkyModel with another instance of the same class to a 
specified angular radius using spherematch() in the geometry 
module</dd>
<dt>subset()       Provide a subset of the sky model using a list of indices onto</dt>
<dd>the existing sky model. Subset can be either in position or 
frequency channels</dd>
<dt>generate_spectrum()</dt>
<dd>Generate and return a spectrum from functional spectral 
parameters</dd>
<dt>to_healpix()   Convert catalog to a healpix format of given nside at </dt>
<dd>specified frequencies.</dd>
</dl>
<dl class="method">
<dt id="astroutils.catalog.SkyModel.generate_spectrum">
<code class="descname">generate_spectrum</code><span class="sig-paren">(</span><em>frequency=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/catalog.html#SkyModel.generate_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.catalog.SkyModel.generate_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and return a spectrum from functional spectral parameters</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>frequency  [scalar or numpy array] Frequencies at which the spectrum at</dt>
<dd>all object locations is to be created. Must be in same units
as the attribute frequency and values under key &#8216;freq-ref&#8217; 
of attribute spec_parms. If not provided (default=None), a 
spectrum is generated for all the frequencies specified in 
the attribute frequency and values under keys &#8216;freq-ref&#8217; and
&#8216;z-width&#8217; of attribute spec_parms.</dd>
</dl>
<p>Outputs:</p>
<dl class="docutils">
<dt>spectrum   [numpy array] Spectrum of the sky model at the respective</dt>
<dd>sky locations. Has shape nobj x nfreq.</dd>
</dl>
<p>Power law calculation uses the convention, 
spectrum = flux_offset + flux_scale * (freq/freq0)**spindex</p>
<p>Monotone places a delta function at the frequency channel closest to the
reference frequency if it lies inside the frequency range, otherwise
a zero spectrum is assigned. 
Thus spectrum = flux_scale * delta(freq-freq0)</p>
<p>Random (currently only gaussian) places random fluxes in the spectrum
spectrum = flux_offset + flux_scale * random_normal(freq.size)</p>
<p>tanh spectrum is defined as (Bowman &amp; Rogers 2010):
spectrum = flux_scale * sqrt((1+z)/10) * 0.5 * [tanh((z-zr)/dz) + 1]
where, flux_scale is typically 0.027 K, zr = reionization redshift 
when x_i = 0.5, and dz = redshift width (dz ~ 1)</p>
<p>If the attribute spec_type is &#8216;spectrum&#8217; the attribute spectrum is 
returned without any modifications.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
</dd></dl>

<dl class="method">
<dt id="astroutils.catalog.SkyModel.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>other</em>, <em>matchrad=None</em>, <em>nnearest=0</em>, <em>maxmatches=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/catalog.html#SkyModel.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.catalog.SkyModel.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the source positions in an instance of class SkyModel with 
another instance of the same class to a specified angular radius using
spherematch() in the geometry module</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>other       [2-column numpy array instance of class SkyModel] Numpy</dt>
<dd>array with two columns specifying the source positions in 
the other sky model or the other instance of class 
SkyModel with which the current instance is to be 
matched with</dd>
<dt>matchrad    [scalar] Angular radius (in degrees) inside which matching </dt>
<dd>should occur. If not specified, if maxmatches is positive, 
all the nearest maxmatches neighbours are found, and if
maxmatches is not positive, the nnearest-th nearest 
neighbour specified by nnearest is found.</dd>
<dt>maxmatches  [scalar] The maximum number of matches (all of the </dt>
<dd>maxmatches nearest neighbours) that lie within matchrad are 
found. If matchrad is not specified, all the maxmatches 
nearest neighbours are found. If maxmatches &lt; 0, and matchrad 
is not set, then the nnearest-th nearest neighbour is found 
(which defaults to the nearest neighbour if nnearest &lt;= 0)</dd>
<dt>nnearest    [scalar] nnearest-th neighbour to be found. Used only when</dt>
<dd>maxmatches is not positive. If matchrad is set, the 
specified neighbour is identified if found inside matchrad, 
otherwise the nnearest-th neighbour is identified regardless
of the angular distance.</dd>
</dl>
<p>Outputs:</p>
<dl class="docutils">
<dt>m1          [list] List of indices of matches in the current instance of</dt>
<dd>class SkyModel</dd>
<dt>m2          [list] List of indices of matches in the other instance of</dt>
<dd>class SkyModel</dd>
<dt>d12         [list] List of angular distances between the matched subsets</dt>
<dd>of the two sky models indexed by m1 and m2 respectively</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="astroutils.catalog.SkyModel.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>outfile</em>, <em>fileformat='hdf5'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/catalog.html#SkyModel.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.catalog.SkyModel.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save sky model to the specified output file</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>outfile     [string] Output filename including full path omitting the</dt>
<dd>extension which will be appended automatically</dd>
<dt>fileformat  [string] format for the output. Accepted values are &#8216;ascii&#8217;</dt>
<dd>and &#8216;hdf5&#8217; (default).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="astroutils.catalog.SkyModel.subset">
<code class="descname">subset</code><span class="sig-paren">(</span><em>indices</em>, <em>axis='position'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/catalog.html#SkyModel.subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.catalog.SkyModel.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a subset of the sky model using a list of indices onto the 
existing sky model. Subset can be either in position or frequency 
channels</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>indices    [list or numpy array] Flattened list or numpy array of </dt>
<dd>indices of sources in the current instance of class SkyModel</dd>
<dt>axis       [string] the axis to take the subset along. Currently </dt>
<dd>accepted values are &#8216;position&#8217; (default) and &#8216;spectrum&#8217; 
which indicates the indices are to be used along the 
position or spectrum axis respectively to obtain the subset.
When spectral axis is specified by spec_type=&#8217;func&#8217;, then 
there will be no slicing along the spectral axis and will 
return the original instance.</dd>
<dt>Output:    [instance of class SkyModel] An instance of class </dt>
<dd>SkyModel holding a subset of the sources in the current 
instance of class SkyModel</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="astroutils.catalog.SkyModel.to_healpix">
<code class="descname">to_healpix</code><span class="sig-paren">(</span><em>freq</em>, <em>nside</em>, <em>in_units='Jy'</em>, <em>out_coords='equatorial'</em>, <em>out_units='K'</em>, <em>outfile=None</em>, <em>outfmt='fits'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/catalog.html#SkyModel.to_healpix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.catalog.SkyModel.to_healpix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert catalog to a healpix format of given nside at specified 
frequencies.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>freq         [scalar or numpy array] Frequencies at which HEALPIX output</dt>
<dd>maps are to be generated</dd>
</dl>
<p>nside        [integer] HEALPIX nside parameter for the output map(s)</p>
<dl class="docutils">
<dt>in_units     [string] Units of input map or catalog. Accepted values are</dt>
<dd>&#8216;K&#8217; for Temperature of &#8216;Jy&#8217; for flux density. Default=&#8217;Jy&#8217;</dd>
<dt>out_coords   [string] Output coordinate system. Accepted values are </dt>
<dd>&#8216;galactic&#8217; and &#8216;equatorial&#8217; (default)</dd>
<dt>out_units    [string] Units of output map. Accepted values are</dt>
<dd>&#8216;K&#8217; for Temperature of &#8216;Jy&#8217; for flux density. Default=&#8217;K&#8217;</dd>
<dt>outfile      [string] Filename with full path to save the output HEALPIX</dt>
<dd>map(s) to. Default=None</dd>
<dt>outfmt       [string] File format for output file. Accepted values are</dt>
<dd>&#8216;fits&#8217; (default) and &#8216;ascii&#8217;</dd>
</dl>
<p>Output(s):</p>
<p>A dictionary with the following keys and values:</p>
<dl class="docutils">
<dt>&#8216;filename&#8217;   Pull path to the output file. Set only if input parameter </dt>
<dd>outfile is set. Default=None.</dd>
<dt>&#8216;spectrum&#8217;   A numpy array of size nsrc x nchan where nsrc is the number </dt>
<dd>sky locations depending on input parameter out_nside and 
nchan is the number of frequencies in input parameter freq</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-astroutils.constants">
<span id="astroutils-constants-module"></span><h2>astroutils.constants module<a class="headerlink" href="#module-astroutils.constants" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-astroutils.cosmotile">
<span id="astroutils-cosmotile-module"></span><h2>astroutils.cosmotile module<a class="headerlink" href="#module-astroutils.cosmotile" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.cosmotile.coeval_interp_cube_to_sphere_surface_wrapper">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">coeval_interp_cube_to_sphere_surface_wrapper</code><span class="sig-paren">(</span><em>interpdict</em>, <em>tiledict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#coeval_interp_cube_to_sphere_surface_wrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.coeval_interp_cube_to_sphere_surface_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate cosmological coeval cubes and transform to produce healpix 
lightcone cube</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>interpdict  [dictionary] See docstring of interp_coevalcubes_inpdict()</dt>
<dd>input, namely, inpdict</dd>
<dt>tiledict    [dictionary] See docstring of </dt>
<dd>convert_coevalcube_to_sphere_surface_inpdict() input, namely, 
inpdict</dd>
</dl>
<p>Output:</p>
<p>Stacked lightcone surfaces of specified sphereical patch (whole sphere if 
nside parameter given). It is of shape npix
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.coeval_interp_cube_to_sphere_surface_wrapper_arg_splitter">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">coeval_interp_cube_to_sphere_surface_wrapper_arg_splitter</code><span class="sig-paren">(</span><em>args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#coeval_interp_cube_to_sphere_surface_wrapper_arg_splitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.coeval_interp_cube_to_sphere_surface_wrapper_arg_splitter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.convert_coevalcube_to_sphere_surface">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">convert_coevalcube_to_sphere_surface</code><span class="sig-paren">(</span><em>inpcube</em>, <em>inpres</em>, <em>nside=None</em>, <em>theta_phi=None</em>, <em>freq=None</em>, <em>redshift=None</em>, <em>method='linear'</em>, <em>rest_freq=1420405751.77</em>, <em>cosmo=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#convert_coevalcube_to_sphere_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.convert_coevalcube_to_sphere_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Covert a cosmological coeval cube at a given resolution (in physical comoving 
distance) to specified coordinates on sphereical surface or whole sphere in 
HEALPIX coordinates</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inpcube     [numpy array] Cosmological cube in three dimensions of comoving</dt>
<dd>distance</dd>
<dt>inpres      [scalar or tuple or list or numpy array] Input cube pixel </dt>
<dd>resolution (in comoving Mpc). If specified as scalar, it is 
applied to all three dimensions. Otherwise a three-element tuple, 
list or numpy array must be specified one for each dimension</dd>
<dt>nside       [scalar] HEALPIX nside parameter for output HEALPIX map. If set</dt>
<dd>theta_phi will be ignored.</dd>
<dt>theta_phi   [numpy array] nsrc x 2 numpy array of theta and phi (in degrees)</dt>
<dd>at which the lightcone surface should be evaluated. One and only
one of nside or theta_phi must be specified.</dd>
<dt>freq        [scalar] Frequency (in Hz) to be processed. One and only one of</dt>
<dd>inputs freq or z (see below) must be set in order to determined
the redshift at which this processing is to take place. Redshift
is necessary to determine the cosmology. If set to None, 
redshift must be specified (see below)</dd>
<dt>redshift    [scalar] Redshift to be processed. One and only one of inputs</dt>
<dd>freq (see above) or redshift must be specified. If set to None, 
freq must be specified (see above)</dd>
<dt>method      [string] Method of interpolation from cube to sphere pixels. </dt>
<dd>Accepted values are &#8216;nearest_rounded&#8217; (fastest but not 
accurate), and those accepted by the input keyword method in 
scipy.interpolate.interpn(), namely, &#8216;linear&#8217; and &#8216;nearest&#8217;, and 
&#8216;splinef2d&#8217;. &#8216;splinef2d&#8217; is only supported for 2-dimensional 
data. Default=&#8217;linear&#8217;</dd>
<dt>rest_freq   [scalar] Rest frame frequency (in Hz) to be used in </dt>
<dd>determination of redshift. Will be used only if freq is set and 
redshift is set to None. Default=1420405751.77 Hz (the rest 
frame frequency of neutral Hydrogen spin flip transition)</dd>
<dt>cosmo       [instance of class astropy.cosmology] Instance of class </dt>
<dd>astropy.cosmology to determine comoving distance for a given
redshift. By default (None) it is set to WMAP9</dd>
</dl>
<p>Output:</p>
<p>lightcone surface of specified patch on sphere or whole sphere in HEALPIX
coordinates. It is of shape nsrc
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.convert_coevalcube_to_sphere_surface_arg_splitter">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">convert_coevalcube_to_sphere_surface_arg_splitter</code><span class="sig-paren">(</span><em>args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#convert_coevalcube_to_sphere_surface_arg_splitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.convert_coevalcube_to_sphere_surface_arg_splitter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.convert_coevalcube_to_sphere_surface_inpdict">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">convert_coevalcube_to_sphere_surface_inpdict</code><span class="sig-paren">(</span><em>inpdict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#convert_coevalcube_to_sphere_surface_inpdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.convert_coevalcube_to_sphere_surface_inpdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Covert a cosmological coeval cube at a given resolution (in physical comoving 
distance) to HEALPIX coordinates of a specified nside covering the whole sky
or coordinates covering a spherical patch. Wrapper for 
convert_coevalcube_to_sphere_surface()</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inpdict     [dictionary] Dictionary of parameters for tiling cosmological </dt>
<dd><p class="first">coeval cubes to healpix lightcone cubes. It consists of the 
following keys and values:
inpcube     [numpy array] Cosmological cube in three dimensions</p>
<blockquote>
<div>of comoving distance</div></blockquote>
<dl class="last docutils">
<dt>inpres      [scalar or tuple or list or numpy array] Input cube </dt>
<dd>pixel resolution (in comoving Mpc). If specified as 
scalar, it is applied to all three dimensions. 
Otherwise a three-element tuple, list or numpy array 
must be specified one for each dimension</dd>
<dt>nside       [scalar] HEALPIX nside parameter for output HEALPIX </dt>
<dd>map. If set theta_phi will be ignored.</dd>
<dt>theta_phi   [numpy array] nsrc x 2 numpy array of theta and phi </dt>
<dd>(in degrees) at which the lightcone surface should 
be evaluated. One and only one of nside or theta_phi 
must be specified.</dd>
<dt>freq        [scalar] Frequency (in Hz) to be processed. One and </dt>
<dd>only one of inputs freq or z (see below) must be set 
in order to determined the redshift at which this 
processing is to take place. Redshift is necessary 
to determine the cosmology. If set to None, redshift 
must be specified (see below)</dd>
<dt>redshift    [scalar] Redshift to be processed. One and only one </dt>
<dd>of inputs freq (see above) or redshift must be 
specified. If set to None, freq must be specified 
(see above)</dd>
<dt>method      [string] Method of interpolation from cube to </dt>
<dd>spherical surface pixels. Accepted values are 
&#8216;nearest_rounded&#8217; (fastest but not accurate), and 
those accepted by the input keyword method in 
scipy.interpolate.interpn(), namely, &#8216;linear&#8217; and 
&#8216;nearest&#8217;, and &#8216;splinef2d&#8217;. &#8216;splinef2d&#8217; is only 
supported for 2-dimensional data. Default=&#8217;linear&#8217;</dd>
<dt>rest_freq   [scalar] Rest frame frequency (in Hz) to be used in </dt>
<dd>determination of redshift. Will be used only if 
freq is set and redshift is set to None. 
Default=1420405751.77 Hz (the rest frame frequency 
of neutral Hydrogen spin flip transition)</dd>
<dt>cosmo       [instance of class astropy.cosmology] Instance of </dt>
<dd>class astropy.cosmology to determine comoving 
distance for a given redshift. By default (None) it 
is set to WMAP9</dd>
</dl>
</dd>
</dl>
<p>Output:</p>
<p>Stacked lightcone surfaces covering spherical patch (whole sky using HEALPIX
if nside is specified) or just at specified theta and phi coordinates. It is 
of shape npix
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.convert_coevalcubes_to_sphere_surfaces">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">convert_coevalcubes_to_sphere_surfaces</code><span class="sig-paren">(</span><em>inpcubes</em>, <em>inpres</em>, <em>nside=None</em>, <em>theta_phi=None</em>, <em>redshifts=None</em>, <em>freqs=None</em>, <em>los_axis=-1</em>, <em>method='linear'</em>, <em>rest_freq=1420405751.77</em>, <em>cosmo=None</em>, <em>parallel=False</em>, <em>nproc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#convert_coevalcubes_to_sphere_surfaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.convert_coevalcubes_to_sphere_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert array of comoving coeval cosmological cubes at a given resolution 
(in physical comoving distance) to HEALPIX coordinates of a specified nside 
covering the whole sky or just a spherical patch using given theta and phi 
coordinates with output as stacked lightcone surfaces</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inpcubes    [numpy array] Array of cosmological coeval cubes in which each </dt>
<dd>element has is a 3D numpy array with three dimensions of comoving 
distance</dd>
<dt>inpres      [scalar or tuple or list or numpy array] Input cube pixel </dt>
<dd>resolution (in comoving Mpc). If specified as scalar, it is 
applied to all three dimensions. Otherwise a three-element tuple, 
list or numpy array must be specified one for each dimension</dd>
<dt>nside       [scalar] HEALPIX nside parameter for output HEALPIX map. If set </dt>
<dd>theta_phi will be ignored.</dd>
<dt>theta_phi   [numpy array] nsrc x 2 numpy array of theta and phi (in degrees) </dt>
<dd>at which the lightcone surface should be evaluated. One and only 
one of nside or theta_phi must be specified.</dd>
<dt>freqs       [scalar] Frequency (in Hz) to be processed. One and only one of</dt>
<dd>inputs freq or z (see below) must be set in order to determined
the redshift at which this processing is to take place. Redshift
is necessary to determine the cosmology. If set to None, 
redshifts must be specified (see below)</dd>
<dt>redshifts   [scalar] Redshift to be processed. One and only one of inputs</dt>
<dd>freqs (see above) or redshifts must be specified. If set to 
None, freqs must be specified (see above)</dd>
<dt>los_axis    [integer] Denotes the axis that is along the line of sight.</dt>
<dd>Default=-1 (last axis)</dd>
<dt>method      [string] Method of interpolation from cube to spherical surface </dt>
<dd>pixels. Accepted values are &#8216;nearest_rounded&#8217; (fastest but not 
accurate), and those accepted by the input keyword method in 
scipy.interpolate.interpn(), namely, &#8216;linear&#8217; and &#8216;nearest&#8217;, and 
&#8216;splinef2d&#8217;. &#8216;splinef2d&#8217; is only supported for 2-dimensional 
data. Default=&#8217;linear&#8217;</dd>
<dt>rest_freq   [scalar] Rest frame frequency (in Hz) to be used in </dt>
<dd>determination of redshift. Will be used only if freq is set and 
redshifts is set to None. Default=1420405751.77 Hz (the rest 
frame frequency of neutral Hydrogen spin flip transition)</dd>
<dt>cosmo       [instance of class astropy.cosmology] Instance of class </dt>
<dd>astropy.cosmology to determine comoving distance for a given
redshift. When set to None (default) it is set to WMAP9.</dd>
<dt>parallel    [boolean] If set to False (default), do serial processing. If</dt>
<dd>set to True, do parallel processing with number of threads as
specified in nproc</dd>
<dt>nproc       [scalar] Number of parallel threads to use. Default=None means</dt>
<dd>it will be set to the number of cores in the system.</dd>
</dl>
<p>Output:</p>
<p>Stacked spherical surfaces either covering whole sky (using nside and 
HEALPIX) or a patch at specified theta and phi for each of the redshifts or 
frequencies. It will be a numpy array of shape nchan x npix
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.cube_smooth_downsample_save">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">cube_smooth_downsample_save</code><span class="sig-paren">(</span><em>inpdict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#cube_smooth_downsample_save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.cube_smooth_downsample_save" title="Permalink to this definition">¶</a></dt>
<dd><p>Read, smooth, downsample and save a cube</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inpdict     [dictionary] It should contain the following keys and values:</dt>
<dd><dl class="first last docutils">
<dt>&#8216;infile&#8217;    [string] Filename containing the raw coeval cube in</dt>
<dd>binary format</dd>
<dt>&#8216;process_stage&#8217;</dt>
<dd>[string] Indicates whether the input file is &#8216;raw&#8217;
(default) or &#8216;processed&#8217;</dd>
<dt>&#8216;smooth_axes&#8217;</dt>
<dd>[int or list/array of ints] Axes to be smoothed as a
list.</dd>
<dt>&#8216;smooth_scale&#8217;</dt>
<dd>[int, float or list] Smoothing scales (in units of 
pixels). If it is a scalar, it will be applied to all
axes specified in &#8216;smooth_axes&#8217; otherwise if given as
a list, its length must match the number of elements 
in &#8216;smooth_axes&#8217;. If set to None, no smoothing is 
done.</dd>
<dt>&#8216;downsample_axes&#8217;</dt>
<dd>[int or list/array of ints] Axes to be downsampled 
as a list. Value under &#8216;indata&#8217; must contain these 
axes</dd>
<dt>&#8216;downsample_factor&#8217;</dt>
<dd>[int, float or list] Downsampling factor. If it is a 
scalar, it will be applied to all axes specified in 
&#8216;downsample_axes&#8217; otherwise if given as
a list, its length must match the number of elements 
in &#8216;downsample_axes&#8217;. If set to None, no downsampling 
is done.</dd>
<dt>&#8216;outfile&#8217;   [string] Filename to save the smoothed and optionally </dt>
<dd>downsampled cube in HDF5 format. No extension should 
be provided as it will be determined internally</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.fastread_21cmfast_cube">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">fastread_21cmfast_cube</code><span class="sig-paren">(</span><em>cubefile</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#fastread_21cmfast_cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.fastread_21cmfast_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 21cmfast cosmological cubes &#8211; coeval or lightcone versions. This is 
faster than read_21cmfast_cube() because it uses numpy.fromfile()</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>cubefile    [string] Filename including full path for reading in the input </dt>
<dd>21cmfast cosmological cube. 21cmfast cubes are stored in binary 
files.</dd>
</dl>
<p>Output:</p>
<p>Numpy array containing the cosmological coeval/lightcone 21cmfast cube. It 
is of shape nx x ny x nz where this is determined by cube dimensions parsed
from the cubefile string
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.interp_coevalcubes">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">interp_coevalcubes</code><span class="sig-paren">(</span><em>invals</em>, <em>outvals</em>, <em>inpcubes=None</em>, <em>cubefiles=None</em>, <em>cubedims=None</em>, <em>cube_source=None</em>, <em>process_stage='raw'</em>, <em>interp_method='linear'</em>, <em>outfiles=None</em>, <em>returncubes=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#interp_coevalcubes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.interp_coevalcubes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate between coeval cosmological cubes at specified parameter values
(usually redshift or frequency) to get the coeval cubes at required parameter
values</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>invals      [list or numpy array] Locations using which the interpolation </dt>
<dd>function is determined. It must be of size equal to the 
dimension of input array along which interpolation is to be 
determined specified by axis keyword input. It must be a list or 
numpy array</dd>
<dt>outvals     [list or numpy array] Locations at which interpolated array is</dt>
<dd>to be determined along the specified axis. It must be a scalar, 
list or numpy array. If any of outloc is outside the range of
inploc, the first and the last cubes from the inparray will
be used as boundary values</dd>
<dt>inpcubes    [list of numpy arrays] List of cosmological coeval cubes in </dt>
<dd>which each element has is a 3D numpy array with three dimensions 
of comoving distance. If set to None (default), cubefiles which 
contain the input cubes must be specified. If set to not None, 
length of the list must match the number of elements in invals. 
Only one of inpcubes or cubefiles can be set</dd>
<dt>cubefiles   [list of strings] Filenames for reading in the input coeval </dt>
<dd>cubes. If set to None (default), inpcubes must be specified. If
set to not None, it must contain a list of filenames and length 
of list must match the number of elements in invals. Only one of 
inpcubes or cubefiles can be set</dd>
<dt>cubedims    [integer, list, tuple or numpy array] Dimensions of the input</dt>
<dd>cubes, will be used when input cubes are read from cubefiles
especially when these are binary files such as from 21cmfast 
simulations. If specified as integer, it will be applied to all
input cubes read from cubefiles, otherwise if specified as a 
list, tuple or numpy array, it must contain three elements one
along each axis and this will be applied to all input cubes read
from cubefiles. It is not applicable when input cubes are given
directly in inpcubes</dd>
<dt>cube_source [string] Source of input cubes. At the moment, the accepted </dt>
<dd>values are &#8216;21cmfast&#8217;</dd>
<dt>process_stage</dt>
<dd>[string] Indicates whether the input file is &#8216;raw&#8217; (default) or 
&#8216;processed&#8217;</dd>
<dt>method      [string] Method of interpolation across coeval cubes along axis</dt>
<dd>for which invals are provided. Usually it is the spectral, 
redshift or line of sight distance. Accepted values are 
&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217; 
where &#8216;slinear&#8217;, &#8216;quadratic&#8217; and &#8216;cubic&#8217; refer to a spline 
interpolation of first, second or third order or as an integer 
specifying the order of the spline interpolator to use. 
Default=&#8217;linear&#8217;.</dd>
<dt>outfiles    [list of strings] Filenames for writing interpolated coeval </dt>
<dd>cubes. If set to None (default), interpolated coeval cubes are 
not written out. If set to not None, it must be a list of 
strings where each element in the list corresponds to filename 
of an interpolated coeval cubes. The number of elements in this 
list must match the number of elements in outvals.</dd>
<dt>returncubes [boolean] If set to True (default), the interpolated coeval</dt>
<dd>cubes are returned as a list of coeval cubes. Thus each element
in the list is a coeval cube and corresponds to the value in
outvals. If set to False, the interpolated coeval cubes are not
returned.</dd>
</dl>
<p>Output:</p>
<p>If input returncubes is set to True, the interpolated coeval cubes are 
returned as a list of coeval cubes. Thus each element in the list is a 
coeval cube and corresponds to the value in outvals. 
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.interp_coevalcubes_arg_splitter">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">interp_coevalcubes_arg_splitter</code><span class="sig-paren">(</span><em>args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#interp_coevalcubes_arg_splitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.interp_coevalcubes_arg_splitter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.interp_coevalcubes_inpdict">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">interp_coevalcubes_inpdict</code><span class="sig-paren">(</span><em>inpdict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#interp_coevalcubes_inpdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.interp_coevalcubes_inpdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate between coeval cosmological cubes at specified parameter values
(usually redshift or frequency) to get the coeval cubes at required parameter
values. Wrapper for interp_coevalcubes()</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inpdict     [dictionary] Dictionary of interpolation parameters for coeval</dt>
<dd><p class="first">cosmological cubes. It consists of the following keys and 
values:
invals      [list or numpy array] Locations using which the</p>
<blockquote>
<div>interpolation function is determined. It must be of 
size equal to the dimension of input array along 
which interpolation is to be determined specified 
by axis keyword input. It must be a list or numpy 
array. This key is mandatory</div></blockquote>
<dl class="last docutils">
<dt>outvals     [list or numpy array] Locations at which </dt>
<dd>interpolated array is to be determined along the 
specified axis. It must be a scalar, list or numpy 
array. If any of outloc is outside the range of 
inploc, the first and the last cubes from the 
inparray will be used as boundary values. This key 
is mandatory</dd>
<dt>inpcubes    [list of numpy arrays] List of cosmological coeval </dt>
<dd>cubes in which each element has is a 3D numpy array 
with three dimensions of comoving distance. If set 
to None (default), cubefiles which contain the input 
cubes must be specified. If set to not None, length 
of the list must match the number of elements in 
invals. Only one of inpcubes or cubefiles can be set</dd>
<dt>cubefiles   [list of strings] Filenames for reading in the input </dt>
<dd>coeval cubes. If set to None (default), inpcubes 
must be specified. If set to not None, it must 
contain a list of filenames and length of list must 
match the number of elements in invals. Only one of 
inpcubes or cubefiles can be set</dd>
<dt>cubedims    [integer, list, tuple or numpy array] Dimensions of </dt>
<dd>the input cubes, will be used when input cubes are 
read from cubefiles especially when these are binary 
files such as from 21cmfast simulations. If 
specified as integer, it will be applied to all 
input cubes read from cubefiles, otherwise if 
specified as a list, tuple or numpy array, it must 
contain three elements one along each axis and this 
will be applied to all input cubes read from 
cubefiles. It is not applicable when input cubes are 
given directly in inpcubes</dd>
<dt>cube_source [string] Source of input cubes. At the moment, the </dt>
<dd>accepted values are &#8216;21cmfast&#8217;</dd>
<dt>method      [string] Method of interpolation across coeval cubes </dt>
<dd>along axis for which invals are provided. Usually it 
is the spectral, redshift or line of sight distance. 
Accepted values are &#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, 
&#8216;slinear&#8217;, &#8216;quadratic&#8217;, &#8216;cubic&#8217; where &#8216;slinear&#8217;, 
&#8216;quadratic&#8217; and &#8216;cubic&#8217; refer to a spline 
interpolation of first, second or third order or as 
an integer specifying the order of the spline 
interpolator to use. Default=&#8217;linear&#8217;.</dd>
<dt>outfiles    [list of strings] Filenames for writing interpolated </dt>
<dd>coeval cubes. If set to None (default), interpolated 
coeval cubes are not written out. If set to not 
None, it must be a list of strings where each 
element in the list corresponds to filename of an 
interpolated coeval cubes. The number of elements in 
this  list must match the number of elements in 
outvals.</dd>
<dt>returncubes [boolean] If set to True (default), the interpolated </dt>
<dd>coeval cubes are returned as a list of coeval cubes. 
Thus each element in the list is a coeval cube and 
corresponds to the value in outvals. If set to 
False, the interpolated coeval cubes are not 
returned.</dd>
</dl>
</dd>
</dl>
<p>Output:</p>
<p>If input returncubes is set to True, the interpolated coeval cubes are 
returned as a list of coeval cubes. Thus each element in the list is a 
coeval cube and corresponds to the value in outvals. 
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.read_21cmfast_cube">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">read_21cmfast_cube</code><span class="sig-paren">(</span><em>cubefile</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#read_21cmfast_cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.read_21cmfast_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 21cmfast cosmological cubes &#8211; coeval or lightcone versions. Use faster
version fastread_21cmfast_cube()</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>cubefile    [string] Filename including full path for reading in the input </dt>
<dd>21cmfast cosmological cube. 21cmfast cubes are stored in binary 
files.</dd>
</dl>
<p>Output:</p>
<p>Numpy array containing the cosmological coeval/lightcone 21cmfast cube. It 
is of shape nx x ny x nz where this is determined by cube dimensions parsed
from the cubefile string
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.read_coeval_cube">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">read_coeval_cube</code><span class="sig-paren">(</span><em>infile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#read_coeval_cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.read_coeval_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Read processed cosmological coeval cubes from HDF5 file</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>infile      [string] Filename including full path where the processed data </dt>
<dd>is to be read in HDF5 format. It should not include the extension 
as it will be determined internally</dd>
</dl>
<p>Output:</p>
<p>Tuple containing processed 21cmfast coeval cube as a 3D numpy array and a 
dictionary that contains header information (set to None if no header info 
found)
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.smooth_downsample_cube">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">smooth_downsample_cube</code><span class="sig-paren">(</span><em>inpdict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#smooth_downsample_cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.smooth_downsample_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a cube and optionally downsample</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inpdict     [dictionary] contains info for smoothing and downsampling. It has</dt>
<dd><p class="first">the following keys and values:
&#8216;indata&#8217;    [numpy array] Coeval cube. Usually it is in 3D
&#8216;smooth_axes&#8217;</p>
<blockquote>
<div>[int or list/array of ints] Axes to be smoothed as a
list. Value under &#8216;indata&#8217; must contain these axes</div></blockquote>
<dl class="last docutils">
<dt>&#8216;smooth_scale&#8217;</dt>
<dd>[int, float or list] Smoothing scales (in units of 
pixels). If it is a scalar, it will be applied to all
axes specified in &#8216;smooth_axes&#8217; otherwise if given as
a list, its length must match the number of elements 
in &#8216;smooth_axes&#8217;. If set to None, no smoothing is 
done.</dd>
<dt>&#8216;downsample_axes&#8217;</dt>
<dd>[int or list/array of ints] Axes to be downsampled 
as a list. Value under &#8216;indata&#8217; must contain these 
axes</dd>
<dt>&#8216;downsample_factor&#8217;</dt>
<dd>[int, float or list] Downsampling factor. If it is a 
scalar, it will be applied to all axes specified in 
&#8216;downsample_axes&#8217; otherwise if given as
a list, its length must match the number of elements 
in &#8216;downsample_axes&#8217;. If set to None, no downsampling 
is done.</dd>
</dl>
</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.write_coeval_cube">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">write_coeval_cube</code><span class="sig-paren">(</span><em>data</em>, <em>outfile</em>, <em>hdrinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#write_coeval_cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.write_coeval_cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Write cosmological coeval cubes to HDF5 file</p>
<p>Inputs:</p>
<p>cube        [numpy array] Coeval cube. Usually 3D.</p>
<dl class="docutils">
<dt>outfile     [string] Filename including full path where the data is to be</dt>
<dd>saved in HDF5 format. It should not include the extension as it
will be determined internally</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.write_lightcone_catalog">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">write_lightcone_catalog</code><span class="sig-paren">(</span><em>init_parms</em>, <em>outfile=None</em>, <em>action='return'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#write_lightcone_catalog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.write_lightcone_catalog" title="Permalink to this definition">¶</a></dt>
<dd><p>Write light cone surfaces to HDF5 file that can be read in as an instance of
class SkyModel</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>init_parms  [dictionary] Dictionary containing parameters used to create</dt>
<dd><p class="first">an instance of class SkyModel. Sky model Initialization 
parameters are specified using the following keys and values
(identical to those used in initializing an instance of class
SkyModel):
&#8216;name&#8217;      [scalar or vector] Name of the catalog. If</p>
<blockquote>
<div>scalar, will be used for all sources in the sky 
model. If vector, will be used for corresponding 
object. If vector, size must equal the number of 
objects.</div></blockquote>
<dl class="last docutils">
<dt>&#8216;frequency&#8217; [scalar or vector] Frequency range for which sky </dt>
<dd>model is applicable. Units in Hz.</dd>
<dt>&#8216;location&#8217;  [numpy array or list of lists] Positions of the </dt>
<dd>sources in sky model. Each position is specified 
as a row (numpy array) or a 2-element list which 
is input as a list of lists for all the sources 
in the sky model</dd>
<dt>&#8216;spec_type&#8217; [string] specifies the flux variation along the </dt>
<dd>spectral axis. Allowed values are &#8216;func&#8217; and 
&#8216;spectrum&#8217;. It must be set to &#8216;spectrum&#8217; and values
for key &#8216;spectrum&#8217; (see below) must be specified.</dd>
<dt>&#8216;spectrum&#8217;  [numpy array] Spectrum of the catalog. Will be </dt>
<dd>applicable if attribute spec_type is set to 
&#8216;spectrum&#8217;. It must be of shape nsrc x nchan</dd>
<dt>&#8216;src_shape&#8217; [3-column numpy array or list of 3-element </dt>
<dd>lists] source shape specified by major axis 
FWHM (first column), minor axis FWHM (second 
column), and position angle (third column). The 
major and minor axes and position angle are 
stored in degrees. The number of rows must match 
the number of sources. Position angle is in 
degrees east of north (same convention as local 
azimuth)</dd>
<dt>&#8216;epoch&#8217;     [string] Epoch appropriate for the coordinate </dt>
<dd>system. Default is &#8216;J2000&#8217;</dd>
<dt>&#8216;coords&#8217;    [string] Coordinate system used for the source </dt>
<dd>positions in the sky model. Currently accepted 
values are &#8216;radec&#8217; (RA-Dec)</dd>
<dt>&#8216;src_shape_units&#8217; </dt>
<dd>[3-element list or tuple of strings] Specifies 
the units of major axis FWHM, minor axis FWHM, 
and position angle. Accepted values for major 
and minor axes units are &#8216;arcsec&#8217;, &#8216;arcmin&#8217;, 
&#8216;degree&#8217;, or &#8216;radian&#8217;. Accepted values for 
position angle units are &#8216;degree&#8217; or &#8216;radian&#8217;</dd>
</dl>
</dd>
<dt>outfile     [string] Output filename including full path omitting the</dt>
<dd>extension (.hdf5) which will be appended automatically. This will
occur only if action is set to &#8216;store&#8217;</dd>
<dt>action      [string] Specifies if the instance of class SkyModel is to be </dt>
<dd>returned if action=&#8217;return&#8217; (default) or save to file specified 
in outfile if action=&#8217;store&#8217;</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.cosmotile.write_lightcone_surfaces">
<code class="descclassname">astroutils.cosmotile.</code><code class="descname">write_lightcone_surfaces</code><span class="sig-paren">(</span><em>light_cone_surfaces</em>, <em>units</em>, <em>outfile</em>, <em>freqs</em>, <em>cosmo=None</em>, <em>is_healpix=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/cosmotile.html#write_lightcone_surfaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.cosmotile.write_lightcone_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Write light cone surfaces to HDF5 file</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>light_cone_surfaces</dt>
<dd>[numpy array] Light cone surfaces. Must be of shape nchan x npix</dd>
</dl>
<p>units       [string] Units of the values in light_cone_surfaces</p>
<p>outfile     [string] Filename to write the output to</p>
<dl class="docutils">
<dt>freqs       [numpy array] The frequencies corresponding to the surfaces. </dt>
<dd>It is of size nchan and units in &#8216;Hz&#8217;</dd>
<dt>cosmo       [dictionary or instance of class astropy.cosmology.FLRW] </dt>
<dd>Cosmological parameters. If specified as dictionary, it must 
contain the following keys and values (no defaults):
&#8216;Om0&#8217;   [float] Matter density parameter at z=0
&#8216;Ode0&#8217;  [float] Dark energy density parameter at z=0
&#8216;Ob0&#8217;   [float] Baryon energy density parameter at z=0
&#8216;h&#8217;     [float] Hubble constant factor in units of km/s/Mpc
&#8216;w0&#8217;    [float] Dark energy equation of state parameter at z=0</dd>
<dt>is_healpix  [boolean] The axis=1 of light_cone_surfaces represents a</dt>
<dd>HEALPIX surface if set to True. If False (default), it may not 
denote a HEALPIX surface.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-astroutils.ephemeris_timing">
<span id="astroutils-ephemeris-timing-module"></span><h2>astroutils.ephemeris_timing module<a class="headerlink" href="#module-astroutils.ephemeris_timing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.ephemeris_timing.gmst2gps">
<code class="descclassname">astroutils.ephemeris_timing.</code><code class="descname">gmst2gps</code><span class="sig-paren">(</span><em>day</em>, <em>GMST</em>, <em>type='mean'</em>, <em>iterations=10</em>, <em>precision=1e-14</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/ephemeris_timing.html#gmst2gps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.ephemeris_timing.gmst2gps" title="Permalink to this definition">¶</a></dt>
<dd><p>gps=gmst2gps(day, GMST, type=&#8217;mean&#8217;, iterations=10, precision=1e-14)
returns the GPS time associated with the GMST/GAST on the given day
type can be &#8216;mean&#8217; or &#8216;apparent&#8217;
uses a root-find, so not super fast
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
</dd></dl>

</div>
<div class="section" id="module-astroutils.foregrounds">
<span id="astroutils-foregrounds-module"></span><h2>astroutils.foregrounds module<a class="headerlink" href="#module-astroutils.foregrounds" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.foregrounds.power_law_spectral_index">
<code class="descclassname">astroutils.foregrounds.</code><code class="descname">power_law_spectral_index</code><span class="sig-paren">(</span><em>freq</em>, <em>flux</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/foregrounds.html#power_law_spectral_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.foregrounds.power_law_spectral_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the power law spectral index when flux densities and frequencies are
specified. If only two frequencies are provided, a power law is computed from 
these two frequencies but if more than two frequencies are specified, the
power law is computed from a polynomial fit of log(flux) vs. log(freq)</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>freq        [list, tuple or numpy array] Frequencies at which flux densities</dt>
<dd>are specified. Must contain at least 2 frequencies.</dd>
<dt>flux        [list, tuple or numpy array] Flux densities at the specified</dt>
<dd>frequencies. Can specify multiple sources at the same. Each
source&#8217;s flux densities must be of the same size as that of freq. 
For instance, if freq is a N-element vector (N &gt;= 2), flux must
be a list of N-element lists or tuples or a MxN numpy array where 
M is the number of sources.</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>verbose     [boolean] If set to True (default) print diagnostic and progress</dt>
<dd>messages, otherwise suppress (False)</dd>
</dl>
<p>Output:</p>
<p>Spectral index for each of the sources whose flux densities are fitted as a
power law function of frequency in log-log units.</p>
</dd></dl>

</div>
<div class="section" id="module-astroutils.geometry">
<span id="astroutils-geometry-module"></span><h2>astroutils.geometry module<a class="headerlink" href="#module-astroutils.geometry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astroutils.geometry.Point">
<em class="property">class </em><code class="descclassname">astroutils.geometry.</code><code class="descname">Point</code><span class="sig-paren">(</span><em>xyz=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#Point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.Point" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to manage 3-dimensional locations in a Cartesian coordinate system.</p>
<p>Attributes:</p>
<p>x       [Scalar] x-coordinate</p>
<p>y       [Scalar] y-coordinate</p>
<p>z       [Scalar] z-coordinate</p>
<p>Member functions:</p>
<p>__init__():   Initializes an instance of class Point</p>
<p>__str__():    Prints the coordinates stored in the instance</p>
<dl class="docutils">
<dt>__add__():    Operator overloading to add two vectors which are represented</dt>
<dd>as instances of class Point</dd>
<dt>__sub__():    Operator overloading to subtract one vector from another</dt>
<dd>which are both represented as instances of class Point</dd>
<dt>__mul__():    Operator overloading to multiply two vectors represented as </dt>
<dd>instances of Point class and produce a dot product.</dd>
<dt>__rmul__():   Operator overlaoding to multiply a vector represented as </dt>
<dd>instance of Point class with a scalar value.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.altaz2dircos">
<code class="descclassname">astroutils.geometry.</code><code class="descname">altaz2dircos</code><span class="sig-paren">(</span><em>altaz</em>, <em>units=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#altaz2dircos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.altaz2dircos" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert altitude and azimuth to direction cosines</p>
<p>Inputs:</p>
<p>altaz:       Altitude and Azimuth as a list of tuples or Nx2 Numpy array</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>units:       [Default = &#8216;radians&#8217;] Units of altitude and azimuth. Could be</dt>
<dd>radians or degrees.</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>dircos:      Direction cosines corresponding to altitude and azimuth. The</dt>
<dd>first axis corresponds to local East, second to local North and
the third corresponds to Up.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.altaz2hadec">
<code class="descclassname">astroutils.geometry.</code><code class="descname">altaz2hadec</code><span class="sig-paren">(</span><em>altaz</em>, <em>latitude</em>, <em>units=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#altaz2hadec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.altaz2hadec" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert altitude and azimuth to HA and declination. Same transformation
function as hadec2altaz, replace azimuth with HA and altitude with declination.</p>
<p>Inputs:</p>
<p>altaz:       Altitude and azimtuh as a list of tuples or Nx2 Numpy array</p>
<p>latitude:    Latitude of the observatory.</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>units:       [Default = &#8216;radians&#8217;] Units of HA, dec and latitude. Could be</dt>
<dd>radians or degrees.</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>hadec:       HA and declination corresponding to altitude and azimuth given</dt>
<dd>latitude. Units are identical to those in input.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.dircos2altaz">
<code class="descclassname">astroutils.geometry.</code><code class="descname">dircos2altaz</code><span class="sig-paren">(</span><em>dircos</em>, <em>units=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#dircos2altaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.dircos2altaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert direction cosines to altitude and azimuth</p>
<p>Inputs:</p>
<p>dircos:      directin cosines as a list of tuples or Nx3 Numpy array</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>units:       [Default = &#8216;radians&#8217;] Units of altitude and azimuth. Could be</dt>
<dd>radians or degrees.</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.ecef2enu">
<code class="descclassname">astroutils.geometry.</code><code class="descname">ecef2enu</code><span class="sig-paren">(</span><em>xyz</em>, <em>ref_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#ecef2enu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.ecef2enu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XYZ in ECEF based on WGS 84 parameters to local ENU coordinates
(Refer to Wikipedia 
<a class="reference external" href="https://en.wikipedia.org/wiki/Geographic_coordinate_conversion">https://en.wikipedia.org/wiki/Geographic_coordinate_conversion</a>)</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>xyz     [numpy array] xyz-coordinates (in m) in ECEF system. It is of size</dt>
<dd>nloc x 3.</dd>
<dt>ref_info</dt>
<dd><p class="first">[dictionary] contains information about the reference point relative 
to which all the ENU coordinates will be estimated. It consists of 
the following keys and information:
&#8216;xyz&#8217;   [3-element numpy array] ECEF XYZ location of the reference</p>
<blockquote>
<div>point</div></blockquote>
<dl class="last docutils">
<dt>&#8216;lat&#8217;   [scalar] geodetic latitude (in radians or degrees as </dt>
<dd>specified by key &#8216;units&#8217;) of reference point</dd>
<dt>&#8216;lon&#8217;   [scalar] geodetic longitude (in radians or degrees as </dt>
<dd>specified by key &#8216;units&#8217;) of reference point</dd>
<dt>&#8216;units&#8217; [string] Specifies units of lat and lon of reference point. </dt>
<dd>Accepted values are &#8216;radians&#8217; (default) or &#8216;degrees&#8217;</dd>
</dl>
</dd>
</dl>
<p>Outputs:</p>
<p>Numpy array containing converted local ENU locations of the input ECEF 
locations. It will be of size nloc x 3
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.ecef2lla">
<code class="descclassname">astroutils.geometry.</code><code class="descname">ecef2lla</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>units='radians'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#ecef2lla"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.ecef2lla" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XYZ in ECEF to geodetic latitude, longitude and altitude coordinates
based on WGS84 parameters</p>
<p>Inputs:</p>
<p>x       [scalar or numpy array] x-coordinate (in m) in ECEF system</p>
<p>y       [scalar or numpy array] y-coordinate (in m) in ECEF system</p>
<p>z       [scalar or numpy array] z-coordinate (in m) in ECEF system</p>
<dl class="docutils">
<dt>units   [string] Specifies units of outputs lat and lon. Accepted values are</dt>
<dd>&#8216;radians&#8217; (default) or &#8216;degrees&#8217;</dd>
</dl>
<p>Outputs:</p>
<p>Tuple (lat, lon, alt) where lat (angle units), lon (angle units) and alt (m) 
are the geodetic latitude, longitudes and altitudes in WGS 84 system
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.enu2ecef">
<code class="descclassname">astroutils.geometry.</code><code class="descname">enu2ecef</code><span class="sig-paren">(</span><em>enu</em>, <em>ref_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#enu2ecef"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.enu2ecef" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert local ENU coordinates to XYZ in ECEF based on WGS 84 parameters
(Refer to Wikipedia 
<a class="reference external" href="https://en.wikipedia.org/wiki/Geographic_coordinate_conversion">https://en.wikipedia.org/wiki/Geographic_coordinate_conversion</a>)</p>
<p>Inputs:</p>
<p>enu     [numpy array] local ENU-coordinates (in m). It is of size nloc x 3.</p>
<dl class="docutils">
<dt>ref_info</dt>
<dd><p class="first">[dictionary] contains information about the reference point relative 
to which all the ECEF coordinates will be estimated. It consists of 
the following keys and information:
&#8216;xyz&#8217;   [3-element numpy array] ECEF XYZ location of the reference</p>
<blockquote>
<div>point</div></blockquote>
<dl class="last docutils">
<dt>&#8216;lat&#8217;   [scalar] geodetic latitude (in radians or degrees as </dt>
<dd>specified by key &#8216;units&#8217;) of reference point</dd>
<dt>&#8216;lon&#8217;   [scalar] geodetic longitude (in radians or degrees as </dt>
<dd>specified by key &#8216;units&#8217;) of reference point</dd>
<dt>&#8216;units&#8217; [string] Specifies units of lat and lon of reference point. </dt>
<dd>Accepted values are &#8216;radians&#8217; (default) or &#8216;degrees&#8217;</dd>
</dl>
</dd>
</dl>
<p>Outputs:</p>
<p>Numpy array containing converted ECEF XYZ locations of the input local ENU 
locations. It will be of size nloc x 3
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.enu2xyz">
<code class="descclassname">astroutils.geometry.</code><code class="descname">enu2xyz</code><span class="sig-paren">(</span><em>enu</em>, <em>latitude</em>, <em>units='radians'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#enu2xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.enu2xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert local ENU coordinates in local tangential plane to XYZ in equatorial
coordinates.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>enu:         local ENU coordinates in local tangential plane as a list of</dt>
<dd>tuples or Nx3 Numpy array. First column refers to local East,
second to local North and third to local Up.</dd>
</dl>
<p>latitude:    Latitude of the observatory.</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>units:       [Default = &#8216;radians&#8217;] Units of latitude. Could be radians or</dt>
<dd>degrees.</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>xyz:         Equatorial XYZ coordinates corresponding to local ENU </dt>
<dd>coordinates given latitude. Units are identical to those in
input. First column refers to X (ha=0, dec=0), second column to
Y (ha=-6h, dec=0), and third column to north celestial pole 
Z (dec=90)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.hadec2altaz">
<code class="descclassname">astroutils.geometry.</code><code class="descname">hadec2altaz</code><span class="sig-paren">(</span><em>hadec</em>, <em>latitude</em>, <em>units=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#hadec2altaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.hadec2altaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert HA and declination to altitude and azimuth</p>
<p>Inputs:</p>
<p>hadec:       HA and declination as a list of tuples or Nx2 Numpy array</p>
<p>latitude:    Latitude of the observatory.</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>units:       [Default = &#8216;radians&#8217;] Units of HA, dec and latitude. Could be</dt>
<dd>&#8216;radians&#8217; or &#8216;degrees&#8217;.</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>altaz:       Altitude and azimuth corresponding to HA and dec at the given</dt>
<dd>latitude. Units are identical to those in input.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.lla2ecef">
<code class="descclassname">astroutils.geometry.</code><code class="descname">lla2ecef</code><span class="sig-paren">(</span><em>lat</em>, <em>lon</em>, <em>alt=None</em>, <em>units='radians'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#lla2ecef"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.lla2ecef" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert geodetic latitude, longitude and altitude to XYZ in ECEF coordinates
based on WGS84 parameters</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>lat     [scalar or numpy array] Geodetic latitude in units specified by </dt>
<dd>input units. Same size as lon and alt</dd>
<dt>lon     [scalar or numpy array] Geodetic longitude in units specified by </dt>
<dd>input units. Same size as lat and alt.</dd>
<dt>alt     [scalar or numpy array] Geodetic altitude in meters. Same size as </dt>
<dd>lat and lon. If set to None, it is assumed to be zeros.</dd>
<dt>units   [string] Specifies units of inputs lat and lon. Accepted values are</dt>
<dd>&#8216;radians&#8217; (default) or &#8216;degrees&#8217;</dd>
</dl>
<p>Outputs:</p>
<p>Tuple (x,y,z) where x, y and z in meters are the components in the ECEF 
system. Each will be of same size as lat
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.parabola_parameters">
<code class="descclassname">astroutils.geometry.</code><code class="descname">parabola_parameters</code><span class="sig-paren">(</span><em>dia=None</em>, <em>f_to_dia_ratio=None</em>, <em>f=None</em>, <em>depth=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#parabola_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.parabola_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute parabola parameters given specific input parameters</p>
<p>Inputs:</p>
<p>Two and only two of the following inputs must be given</p>
<p>dia         [scalar or numpy array] Width of the parabola</p>
<dl class="docutils">
<dt>f_to_dia_ratio</dt>
<dd>[scalar or numpy array] ratio of focal distance to width</dd>
</dl>
<p>f           [scalar or numpy array] focal distance</p>
<p>depth       [scalar or numpy array] depth of the parabola</p>
<p>Output:</p>
<p>Dictionary containing the following keys and values:
&#8216;f&#8217;         [numpy array] focal distance
&#8216;D&#8217;         [numpy array] width of the parabola
&#8216;h&#8217;         [numpy array] depth of the parabola
&#8216;f/D&#8217;       [numpy array] ratio of focal distance to diameter
&#8216;angle&#8217;     [scalar or numpy array] Opening angle between the edge and the</p>
<blockquote>
<div>axis of the parabola</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.sample_parabola">
<code class="descclassname">astroutils.geometry.</code><code class="descname">sample_parabola</code><span class="sig-paren">(</span><em>f</em>, <em>open_angle</em>, <em>wavelength=1.0</em>, <em>axis=90.0</em>, <em>angunits='degrees'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#sample_parabola"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.sample_parabola" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample points on a parabola defined by focal length and opening angle</p>
<p>Inputs:</p>
<p>f       [scalar] focal length, must be positive</p>
<dl class="docutils">
<dt>open_angle</dt>
<dd>[scalar] opening angle (in units specified by input angunits) which
is defined as the angle the edge of the parabola measured from the
vertex of the parabola</dd>
<dt>axis    [scalar] Angle the principal axis makes with the horizon (x-axis)</dt>
<dd>measured counter-clockwise towards the z-axis (zenith). Default=90 
degrees implies it is along the zenith</dd>
<dt>wavelength</dt>
<dd>[scalar] Wavelength to calculate the sampling interval. At the 
moment the sampling interval is fixed at one-tenth of whichever 
is minimum between the wavelength and diameter of the parabola</dd>
<dt>angunits</dt>
<dd>[string] Units of the angles specified in open_angle and axis. By
default, it is set to &#8216;degrees&#8217;</dd>
</dl>
<p>Output:</p>
<p>Mx3 array of x, y, z positions in same units as input focal length. The 
y-values are zeros.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.sample_paraboloid">
<code class="descclassname">astroutils.geometry.</code><code class="descname">sample_paraboloid</code><span class="sig-paren">(</span><em>f, open_angle, wavelength=1.0, axis=[90.0, 270.0], angunits='degrees'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#sample_paraboloid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.sample_paraboloid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample points on a parabola defined by focal length and opening angle</p>
<p>Inputs:</p>
<p>f       [scalar] focal length, must be positive</p>
<dl class="docutils">
<dt>open_angle</dt>
<dd>[scalar] opening angle (in units specified by input angunits) which
is defined as the angle the edge of the parabola measured from the
vertex of the parabola</dd>
<dt>axis    [list or numpy array] Angles (alta, az) the principal axis makes </dt>
<dd>relative to zenith. Default=[90, 270] degrees implies it is along 
the z-axis (zenith)</dd>
<dt>wavelength</dt>
<dd>[scalar] Wavelength to calculate the sampling interval. At the 
moment the sampling interval is fixed at one-tenth of whichever 
is minimum between the wavelength and diameter of the parabola</dd>
<dt>angunits</dt>
<dd>[string] Units of the angles specified in open_angle and axis. By
default, it is set to &#8216;degrees&#8217;</dd>
</dl>
<p>Output:</p>
<p>Mx3 array of x, y, z positions in same units as input focal length. The 
y-values are zeros.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.sph2xyz">
<code class="descclassname">astroutils.geometry.</code><code class="descname">sph2xyz</code><span class="sig-paren">(</span><em>lon</em>, <em>lat</em>, <em>rad=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#sph2xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.sph2xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from spherical coordinates (radius, latitude, longigtude) to 
Cartesian coordinates</p>
<p>Inputs:</p>
<p>lon [scalar or vector] longitude in degrees.</p>
<p>lat [scalar or vector] latitude in degrees. Same size as lon.</p>
<dl class="docutils">
<dt>rad [Optional. scalar or vector] radius. Same size as lon and lat.</dt>
<dd>Default = 1.0</dd>
</dl>
<p>Outputs:</p>
<p>x   [scalar or vector] x-coordinates. Same size as lon and lat</p>
<p>y   [scalar or vector] y-coordinates. Same size as lon and lat</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.sphdist">
<code class="descclassname">astroutils.geometry.</code><code class="descname">sphdist</code><span class="sig-paren">(</span><em>lon1</em>, <em>lat1</em>, <em>lon2</em>, <em>lat2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#sphdist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.sphdist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns great circle distance.</p>
<p>Uses vicenty distance formula - a bit slower than others, but numerically
stable.</p>
<p>Inputs:</p>
<p>lon1 [scalar or vector] Longtitude in first list in degrees</p>
<dl class="docutils">
<dt>lat1 [scalar or vector] Latitude in first list in degrees. Must be of same</dt>
<dd>size as lon1 if vector</dd>
<dt>lon2 [scalar or vector] Longtitude in second list in degrees. Must be of same</dt>
<dd>size as lon1 if vector</dd>
<dt>lat2 [scalar or vector] Latitude in second list in degrees. Must be of same</dt>
<dd>size as lon1 if vector</dd>
</dl>
<p>Outputs:</p>
<p>Angular distance (in degrees) subtended on the great circle between the given
set of points. Same size as the inputs.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.spherematch">
<code class="descclassname">astroutils.geometry.</code><code class="descname">spherematch</code><span class="sig-paren">(</span><em>lon1</em>, <em>lat1</em>, <em>lon2=None</em>, <em>lat2=None</em>, <em>matchrad=None</em>, <em>nnearest=0</em>, <em>maxmatches=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#spherematch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.spherematch" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds matches in one catalog to another. Matches for the first catalog are
searched for in the second catalog.</p>
<p>Parameters
lon1 : array-like</p>
<blockquote>
<div>Longitude-like (RA, etc.) coordinate in degrees of the first catalog</div></blockquote>
<dl class="docutils">
<dt>lat1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span><dd>Latitude-like (Dec, etc.) coordinate in degrees of the first catalog
(shape of array must match <cite>lon1</cite>)</dd>
<dt>lon2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span><dd>Latitude-like (RA, etc.) coordinate in degrees of the second catalog</dd>
<dt>lat2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">array-like</span><dd>Latitude-like (Dec, etc.) in degrees of the second catalog (shape of
array must match <cite>ra2</cite>)</dd>
<dt>matchrad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or None, optional</span><dd>How close (in degrees) a match has to be to count as a match.  If None,
all nearest neighbors for the first catalog will be returned.</dd>
<dt>nnearest</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span><dd>The nth nearest neighbor to find. Default = 0 (if maxmatches &gt;= 0,
maxmatches is used, else nnearest is set to 1 thereby searching for the
first nearest neighbour)</dd>
<dt>maxmatches</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span><dd>Maximum number of matches to find. If maxmatches &gt; 0, the code finds 
all matches up to maxmatches satisfying matchrad. If maxmatches = 0, all
matches upto matchrad are found. And nnearest is ignored. Default = -1 
(nnearest, if positive, is used instead of maxmatches. if nnearest is 0, 
then nnearest is set to 1 and the first nearest neighbour is searched.)</dd>
</dl>
<dl class="docutils">
<dt>m1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int array</span><dd>Indices into the first catalog of the matches.</dd>
<dt>m2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int array</span><dd>Indices into the second catalog of the matches.</dd>
<dt>d12</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float array</span><dd>Distance (in degrees) between the matches</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.xyz2enu">
<code class="descclassname">astroutils.geometry.</code><code class="descname">xyz2enu</code><span class="sig-paren">(</span><em>xyz</em>, <em>latitude</em>, <em>units='radians'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#xyz2enu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.xyz2enu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert equatorial XYZ coordinates to local ENU coordinates in the local 
tangential plane.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>xyz:         equatorial XYZ coordinates as a list of tuples or Nx3 Numpy</dt>
<dd>array. First column refers to X (ha=0, dec=0), second column to
Y (ha=-6h, dec=0), and third column to north celestial pole 
Z (dec=90)</dd>
</dl>
<p>latitude:    Latitude of the observatory.</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>units:       [Default = &#8216;radians&#8217;] Units of latitude. Could be radians or</dt>
<dd>degrees.</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>enu:         local ENU coordinates in the local tangential plane</dt>
<dd>corresponding to equatorial XYZ coordinates given latitude.
Units are identical to those in input. First column refers to 
local East, second to local North and third to local Up.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.geometry.xyz2sph">
<code class="descclassname">astroutils.geometry.</code><code class="descname">xyz2sph</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>units='radians'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/geometry.html#xyz2sph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.geometry.xyz2sph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from Cartesian coordinates to spherical coordinates (radius, latitude
and longitude)</p>
<p>Inputs:</p>
<p>x       [scalar or vector] x-coordinates. Same size as y and z</p>
<p>y       [scalar or vector] y-coordinates. Same size as x and z</p>
<p>z       [scalar or vector] z-coordinates. Same size as x and y</p>
<dl class="docutils">
<dt>units   [string] Specifies units of output latitude and longitude. If set</dt>
<dd>to &#8216;degrees&#8217; it will be in degrees, otherwise in radians</dd>
</dl>
<p>Outputs:</p>
<p>r   [scalar or vector] radius. Same size and units as x, y and z</p>
<p>lon [scalar or vector] longitude in units specified by keyword input &#8216;units&#8217;</p>
</dd></dl>

</div>
<div class="section" id="module-astroutils.gridding_modules">
<span id="astroutils-gridding-modules-module"></span><h2>astroutils.gridding_modules module<a class="headerlink" href="#module-astroutils.gridding_modules" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.gridding_modules.conv_grid1d">
<code class="descclassname">astroutils.gridding_modules.</code><code class="descname">conv_grid1d</code><span class="sig-paren">(</span><em>xc</em>, <em>xkern</em>, <em>kernel</em>, <em>xgrid</em>, <em>method='NN'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/gridding_modules.html#conv_grid1d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.gridding_modules.conv_grid1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform 1D gridding convolution.
Inputs:</p>
<dl class="docutils">
<dt>xc:      [vector as list or numpy array] x-coordinates of center of gridding</dt>
<dd>function</dd>
</dl>
<p>xkern:   [vector as list or numpy array] x-coordinates of gridding function</p>
<dl class="docutils">
<dt>kernel:  [vector as list or numpy array] gridding function (or kernel). If</dt>
<dd>kernel is a scalar, a nearest neighbour interpolation is used
overriding the method requested for. This kernel will be
interpolated at the requested locations in xgrid</dd>
<dt>xgrid:   [vector as list or numpy array] x-coordinates of grid locations at</dt>
<dd>which interpolates are required</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>method:  String indicating interpolation method. [Default = &#8216;NN&#8217;]</dt>
<dd>&#8216;NN&#8217; =&gt; Nearest Neighbour 
&#8216;SL&#8217; =&gt; Single linear
&#8216;CS&#8217; =&gt; Cubic Spline</dd>
</dl>
<p>Output:</p>
<p>outdata: [vector] Gridded values at values of xgrid</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.gridding_modules.conv_grid2d">
<code class="descclassname">astroutils.gridding_modules.</code><code class="descname">conv_grid2d</code><span class="sig-paren">(</span><em>xc</em>, <em>yc</em>, <em>xkern</em>, <em>ykern</em>, <em>kernel</em>, <em>xgrid</em>, <em>ygrid</em>, <em>method='NN'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/gridding_modules.html#conv_grid2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.gridding_modules.conv_grid2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform gridding convolution.
Inputs:</p>
<dl class="docutils">
<dt>xc:      [vector as list of numpy array] x-coordinates of center of gridding</dt>
<dd>function</dd>
<dt>yc:      [vector as list or numpy array] y-coordinates of center of gridding</dt>
<dd>function</dd>
</dl>
<p>xkern:   [vector as list or numpy array] x-coordinates of gridding function</p>
<p>ykern:   [vector as list or numpy array] y-coordinates of gridding function</p>
<dl class="docutils">
<dt>kernel:  [vector as list or numpy array] gridding function (or kernel). If</dt>
<dd>kernel is a scalar, a nearest neighbour interpolation is used
overriding the method requested for. This kernel will be
interpolated at the requested locations in (xgrid, ygrid)</dd>
<dt>xgrid:   [vector as list or numpy array] x-coordinates of grid locations at</dt>
<dd>which interpolates are required</dd>
<dt>ygrid:   [vector as list or numpy array] y-coordinates of grid locations at</dt>
<dd>which interpolates are required</dd>
</dl>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>method:  String indicating interpolation method. [Default = &#8216;NN&#8217;]</dt>
<dd>&#8216;NN&#8217; =&gt; Nearest Neighbour 
&#8216;BL&#8217; =&gt; Bilinear
&#8216;CS&#8217; =&gt; Cubic Spline</dd>
</dl>
<p>Output:</p>
<p>outdata: [vector] Gridded values at values of (xgrid, ygrid)</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.gridding_modules.grid">
<code class="descclassname">astroutils.gridding_modules.</code><code class="descname">grid</code><span class="sig-paren">(</span><em>rangelist</em>, <em>pad=None</em>, <em>spacing=None</em>, <em>pow2=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/gridding_modules.html#grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.gridding_modules.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a multi-dimensional grid.</p>
<p>Inputs:
rangelist [list of tuples] Each tuple is made of two elements, the min and</p>
<blockquote>
<div>max with min &lt; max. One tuple for each axis.</div></blockquote>
<dl class="docutils">
<dt>pad       [Optional. Scalar or list] The padding (in same units as range) to</dt>
<dd>be applied along the axes. Default=None implies no padding.</dd>
<dt>spacing   [Optional. Scalar or list] The spacing for the grid along each of</dt>
<dd>the axes. If not supplied, a default of sqrt(max-min) is used. If a
scalar is supplied, it applies for all axes. A list applies for
each of the axes.</dd>
<dt>pow2      [Optional, default=True] If set, the grid produced is a power of 2</dt>
<dd>in all axes, which is useful for FFT.</dd>
</dl>
<p>verbose   [Default=True]</p>
<p>Outputs:</p>
<dl class="docutils">
<dt>tupleout  [List of tuples] A 4-element tuple for each axis. The elements in</dt>
<dd>each tuple are min, max, lengths, and spacing (which could have
been modified relative to input). The precise grid points can be
generated by using numpy&#8217;s linspace using min, max and lengths.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.gridding_modules.grid_1d">
<code class="descclassname">astroutils.gridding_modules.</code><code class="descname">grid_1d</code><span class="sig-paren">(</span><em>ranges</em>, <em>pad=None</em>, <em>spacing=None</em>, <em>pow2=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/gridding_modules.html#grid_1d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.gridding_modules.grid_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D wrapper for grid()</p>
<p>Inputs:
ranges   [2-element list or a tuple with 2 elements] min and max with</p>
<blockquote>
<div>min &lt; max.</div></blockquote>
<dl class="docutils">
<dt>pad      [Optional or Scalar] The padding (in same units as ranges) to be</dt>
<dd>applied along the axis. Default=None implies no padding.</dd>
<dt>spacing  [Optional or Scalar] The spacing for the grid along the axis. If not</dt>
<dd>supplied, a default of sqrt(max-min) is used.</dd>
<dt>pow2     [Optional, default=True] If set, the grid produced is a power of 2</dt>
<dd>in its axis, which is useful for FFT.</dd>
</dl>
<p>verbose  [Default=True]</p>
<p>Outputs:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.gridding_modules.grid_2d">
<code class="descclassname">astroutils.gridding_modules.</code><code class="descname">grid_2d</code><span class="sig-paren">(</span><em>rangelist</em>, <em>pad=None</em>, <em>spacing=None</em>, <em>pow2=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/gridding_modules.html#grid_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.gridding_modules.grid_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D wrapper for grid()</p>
<p>Inputs:
rangelist</p>
<blockquote>
<div>[2-element list of tuples] Each tuple is made of two elements, the
min and max with min &lt; max.</div></blockquote>
<dl class="docutils">
<dt>pad      [Optional. Scalar or list] The padding (in same units as rangelist) to</dt>
<dd>be applied along the two axes. Default=None implies no padding.</dd>
<dt>spacing  [Optional. Scalar or list] The spacing for the grid along each of</dt>
<dd>the axes. If not supplied, a default of sqrt(max-min) is used. If a
scalar is supplied, it applies for all axes. A list applies for each
of the axes.</dd>
<dt>pow2     [Optional, default=True] If set, the grid produced is a power of 2</dt>
<dd>in all axes, which is useful for FFT.</dd>
</dl>
<p>verbose  [Default=True]</p>
<p>Outputs:</p>
<p>Two 2D numpy arrays. The first array with x-values on the grid, and the
second with y-values on the grid.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.gridding_modules.grid_3d">
<code class="descclassname">astroutils.gridding_modules.</code><code class="descname">grid_3d</code><span class="sig-paren">(</span><em>rangelist</em>, <em>pad=None</em>, <em>spacing=None</em>, <em>pow2=True</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/gridding_modules.html#grid_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.gridding_modules.grid_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D wrapper for grid()</p>
<p>Inputs:
rangelist</p>
<blockquote>
<div>[3-element list of tuples] Each tuple is made of two elements, the
min and max with min &lt; max.</div></blockquote>
<dl class="docutils">
<dt>pad      [Optional. Scalar or list] The padding (in same units as rangelist) to</dt>
<dd>be applied along the two axes. Default=None implies no padding.</dd>
<dt>spacing  [Optional. Scalar or list] The spacing for the grid along each of</dt>
<dd>the axes. If not supplied, a default of sqrt(max-min) is used. If a
scalar is supplied, it applies for all axes. A list applies for each
of the axes.</dd>
<dt>pow2     [Optional, default=True] If set, the grid produced is a power of 2</dt>
<dd>in all axes, which is useful for FFT.</dd>
</dl>
<p>verbose  [Default=True]</p>
<p>Outputs:</p>
<p>Three 3D numpy arrays. The first array with x-values, the second with 
y-values, and the third with z-values on the grid.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

</div>
<div class="section" id="module-astroutils.kernel_density_estimator">
<span id="astroutils-kernel-density-estimator-module"></span><h2>astroutils.kernel_density_estimator module<a class="headerlink" href="#module-astroutils.kernel_density_estimator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.kernel_density_estimator.fast_kde">
<code class="descclassname">astroutils.kernel_density_estimator.</code><code class="descname">fast_kde</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>gridsize=(400</em>, <em>400)</em>, <em>extents=None</em>, <em>weights=None</em>, <em>sample=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/kernel_density_estimator.html#fast_kde"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.kernel_density_estimator.fast_kde" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a gaussian kernel density estimate over a regular grid using a
convolution of the gaussian kernel with a 2D histogram of the data.</p>
<p>This function is typically several orders of magnitude faster than
scipy.stats.kde.gaussian_kde for large (&gt;1e7) numbers of points and
produces an essentially identical result.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>x: array-like</dt>
<dd>The x-coords of the input data points</dd>
<dt>y: array-like</dt>
<dd>The y-coords of the input data points</dd>
<dt>gridsize: tuple, optional</dt>
<dd>An (nx,ny) tuple of the size of the output
grid. Defaults to (400, 400).</dd>
<dt>extents: tuple, optional</dt>
<dd>A (xmin, xmax, ymin, ymax) tuple of the extents of output grid.
Defaults to min/max of x &amp; y input.</dd>
<dt>weights: array-like or None, optional</dt>
<dd>An array of the same shape as x &amp; y that weighs each sample (x_i,
y_i) by each value in weights (w_i).  Defaults to an array of ones
the same size as x &amp; y.</dd>
<dt>sample: boolean</dt>
<dd>Whether or not to return the estimated density at each location.
Defaults to False</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd><dl class="first last docutils">
<dt>density</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array of shape <em>gridsize</em></span><dd>The estimated probability distribution function on a regular grid</dd>
<dt>extents</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span><dd>xmin, xmax, ymin, ymax</dd>
<dt>sampled_density</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array of len(<em>x</em>)</span><dd>Only returned if <em>sample</em> is True.  The estimated density at each
point.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.kernel_density_estimator.generate_data">
<code class="descclassname">astroutils.kernel_density_estimator.</code><code class="descname">generate_data</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/kernel_density_estimator.html#generate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.kernel_density_estimator.generate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.kernel_density_estimator.image_cov">
<code class="descclassname">astroutils.kernel_density_estimator.</code><code class="descname">image_cov</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/kernel_density_estimator.html#image_cov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.kernel_density_estimator.image_cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently calculate the cov matrix of an image.</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.kernel_density_estimator.image_example">
<code class="descclassname">astroutils.kernel_density_estimator.</code><code class="descname">image_example</code><span class="sig-paren">(</span><em>grid</em>, <em>extents</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/kernel_density_estimator.html#image_example"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.kernel_density_estimator.image_example" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.kernel_density_estimator.main">
<code class="descclassname">astroutils.kernel_density_estimator.</code><code class="descname">main</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/kernel_density_estimator.html#main"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.kernel_density_estimator.main" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.kernel_density_estimator.scatter_example">
<code class="descclassname">astroutils.kernel_density_estimator.</code><code class="descname">scatter_example</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>density</em>, <em>num_points=10000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/kernel_density_estimator.html#scatter_example"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.kernel_density_estimator.scatter_example" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-astroutils.lookup_operations">
<span id="astroutils-lookup-operations-module"></span><h2>astroutils.lookup_operations module<a class="headerlink" href="#module-astroutils.lookup_operations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.lookup_operations.find_1NN">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">find_1NN</code><span class="sig-paren">(</span><em>ref</em>, <em>inp</em>, <em>distance_ULIM=inf</em>, <em>remove_oob=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#find_1NN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.find_1NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first nearest neighbour of input locations from a set of reference 
locations using KD-Trees nearest neighbour algorithm.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ref     [numpy array] Reference locations to be looked up to. NxK numpy </dt>
<dd>array which represents N points in K-dimensional coordinates</dd>
<dt>inp     [numpy array] Input locations for which nearest neighbours will be</dt>
<dd>searched in reference locations specified in ref. MxK numpy array
representing M points in K-dimensional coordinates. Must have same
number of columns as input parameter ref.</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple in the following order:
index of input location (inpind), nearest neighbour distance in the lookup 
table (distNN), and the index of the nearest neighbour in the lookup table 
(refind).
The number of pairs matched will be the lesser of those determined by distNN
and maxmatch</p>
<dl class="docutils">
<dt>inpind  [numpy vector] indices of the input locations for which nearest </dt>
<dd>neighbours were found from the lookup table. If remove_oob is 
not set to True, size of inpind is equal to size of xin or yin, 
otherwise size of inpind is less than or equal to size of xin or yin. 
Values of inpind equal to size of lookup table values indicates the 
nearest neighbours for the corresponding input location could not be 
found within the distance upper bound from the lookup table. The
corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to size of xin or yin, otherwise size of distNN is 
less than or equal to size of xin or yin. In such a case, out of 
bound locations are filled with inf or NP.inf.</dd>
<dt>refind  [numpy vector] indices of the nearest neighbours in the reference </dt>
<dd>lookup table. i.e., ref[refind,:] are the nearest neighbours of 
inp[inpind] with distances distNN.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.find_1NN_old">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">find_1NN_old</code><span class="sig-paren">(</span><em>ref</em>, <em>inp</em>, <em>distance_ULIM=inf</em>, <em>remove_oob=True</em>, <em>maxmatch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#find_1NN_old"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.find_1NN_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first nearest neighbour of input locations to a set of reference 
locations using KD-Trees nearest neighbour algorithm.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ref     [numpy array] Reference locations to be looked up to. NxK numpy </dt>
<dd>array which represents N points in K-dimensional coordinates</dd>
<dt>inp     [numpy array] Input locations for which nearest neighbours will be</dt>
<dd>searched in reference locations specified in ref. MxK numpy array
representing M points in K-dimensional coordinates. Must have same
number of columns as input parameter ref.</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple in the following order:
index of input location (inpind), nearest neighbour distance in the lookup 
table (distNN), and the index of the nearest neighbour in the lookup table 
(refind).
The number of pairs matched will be the lesser of those determined by distNN
and maxmatch</p>
<dl class="docutils">
<dt>inpind  [numpy vector] indices of the input locations for which nearest </dt>
<dd>neighbours were found from the lookup table. If remove_oob is 
not set to True, size of inpind is equal to size of xin or yin, 
otherwise size of inpind is less than or equal to size of xin or yin. 
Values of inpind equal to size of lookup table values indicates the 
nearest neighbours for the corresponding input location could not be 
found within the distance upper bound from the lookup table. The
corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to size of xin or yin, otherwise size of distNN is 
less than or equal to size of xin or yin. In such a case, out of 
bound locations are filled with inf or NP.inf.</dd>
<dt>refind  [numpy vector] indices of the nearest neighbours in the reference </dt>
<dd>lookup table. i.e., ref[refind,:] are the nearest neighbours of 
inp[inpind] with distances distNN.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.find_1NN_pp">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">find_1NN_pp</code><span class="sig-paren">(</span><em>ref</em>, <em>inp</em>, <em>pid</em>, <em>outq</em>, <em>distance_ULIM=inf</em>, <em>remove_oob=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#find_1NN_pp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.find_1NN_pp" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first nearest neighbour of input locations to a set of reference 
locations using KD-Trees nearest neighbour algorithm. Identical to 
find_1NN_pp() but should be used only in case of parallel programming
applications</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ref     [numpy array] Reference locations to be looked up to. NxK numpy </dt>
<dd>array which represents N points in K-dimensional coordinates</dd>
<dt>inp     [numpy array] Input locations for which nearest neighbours will be</dt>
<dd>searched in reference locations specified in ref. MxK numpy array
representing M points in K-dimensional coordinates. Must have same
number of columns as input parameter ref.</dd>
<dt>pid     [any scalar] process id which will be used as a key in the returned </dt>
<dd>dictionary</dd>
<dt>outq    [instance of multiprocessing.Queue] Output dictionary will be </dt>
<dd>returned in outq</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a dictionary with key given by pid and contains a nested dictionary
with the following keys and values: 
&#8216;inpind&#8217;  [numpy vector] indices of the input locations for which nearest</p>
<blockquote>
<div>neighbours were found from the lookup table. If remove_oob is 
not set to True, size of inpind is equal to size of xin or yin, 
otherwise size of inpind is less than or equal to size of xin or 
yin. Values of inpind equal to size of lookup table values 
indicates the nearest neighbours for the corresponding input 
location could not be found within the distance upper bound from 
the lookup table. The corresponding values in distNN are returned 
as inf or NP.inf</div></blockquote>
<dl class="docutils">
<dt>&#8216;distNN&#8217;  [numpy vector] distance to the nearest neighbour in the lookup </dt>
<dd>table for the given input locations. If remove_oob is not set to 
True, size of distNN is equal to size of xin or yin, otherwise 
size of distNN is less than or equal to size of xin or yin. In 
such a case, out of bound locations are filled with inf or NP.inf.</dd>
<dt>&#8216;refind&#8217;  [numpy vector] indices of the nearest neighbours in the reference </dt>
<dd>lookup table. i.e., ref[refind,:] are the nearest neighbours of 
inp[inpind] with distances distNN.</dd>
</dl>
<p>The number of pairs matched will be the lesser of those determined by distNN
and maxmatch
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.find_NN">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">find_NN</code><span class="sig-paren">(</span><em>ngbrof</em>, <em>ngbrin</em>, <em>distance_ULIM=inf</em>, <em>flatten=False</em>, <em>parallel=False</em>, <em>nproc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#find_NN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.find_NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all nearest neighbours of one set of locations in another set of 
locations within a specified distance.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ngbrof    [numpy array] Locations for nearest neighbours are to be </dt>
<dd>determined. Has dimensions MxK where M is the number of locations.</dd>
<dt>ngbrin    [numpy array] Locations from which nearest neighbours are to be </dt>
<dd>chosen for the locations in ngbrof. Has dimensions NxK.</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] Maximum search radius to look for neighbours. 
Default=NP.inf</dd>
<dt>flatten   [boolean] If set to True, flattens the output of the nearest</dt>
<dd>neighbour search algorithm to yield two separate sets of matching
indices - one for ngbrof and the other for ngbrin. Default=False</dd>
<dt>parallel  [boolean] specifies if parallelization is to be invoked. False </dt>
<dd>(default) means only serial processing. Parallelization is done
over ngbrof</dd>
<dt>nproc     [scalar] specifies number of independent processes to spawn.</dt>
<dd>Default=None, means automatically determines the number of 
process cores in the system and use one less than that to 
avoid locking the system for other processes. Applies only 
if input parameter &#8216;parallel&#8217; (see above) is set to True. 
If nproc is set to a value more than the number of process
cores in the system, it will be reset to number of process 
cores in the system minus one to avoid locking the system out 
for other processes</dd>
</dl>
<p>Outputs:</p>
<p>List containing three items. The first item is a list of M lists where each 
of the M inner lists corresponds to one entry in ngbrof and the elements in 
the inner list contains indices to ngbrin that are the nearest neighbours of 
that specific ngbrof (same as output of cKDTree.query_ball_tree()). The 
second item in the output list is a numpy array of indices to ngbrof 
(obtained from the first item if input keyword flatten is set to True) or 
None (if input keyword flatten is set to False). The third item in the output 
list is a numpy array of indices to ngbrin that is a valid neighbour of 
ngbrof (obtained from the first item if input keyword flatten is set to 
True) or None (if input keyword flatten is set to False). 
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.find_NN_arg_splitter">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">find_NN_arg_splitter</code><span class="sig-paren">(</span><em>args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#find_NN_arg_splitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.find_NN_arg_splitter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.find_NN_pp">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">find_NN_pp</code><span class="sig-paren">(</span><em>ngbrof</em>, <em>ngbrin</em>, <em>distance_ULIM</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#find_NN_pp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.find_NN_pp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.gen_lookup">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">gen_lookup</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>data</em>, <em>outfile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#gen_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.gen_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a lookup table given two-dimensional coordinates and values at these
coordinates.</p>
<p>Inputs:</p>
<p>x          [numpy vector] x-coordinates for the lookup values.</p>
<p>y          [numpy vector] y-coordinates for the lookup values</p>
<dl class="docutils">
<dt>data       [numpy vector] data values at the coordinates given by x and y. x,</dt>
<dd>y, and data must all have the same size</dd>
<dt>outfile    [string] Name of the output file to write the lookup table to. It </dt>
<dd>will be created as an ascii table with &#8216;x&#8217;, &#8216;y&#8217;, &#8216;real_value&#8217; and 
&#8216;imag_value&#8217; (if imagianry value present) being the column headers</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.lookup">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">lookup</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>val</em>, <em>xin</em>, <em>yin</em>, <em>distance_ULIM=inf</em>, <em>oob_value=0.0</em>, <em>remove_oob=True</em>, <em>tol=None</em>, <em>maxmatch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lookup operation based on nearest neighbour algorithm using
KD-Trees when the lookup database and required coordinate locations are
specified.</p>
<p>Inputs:</p>
<p>x       [numpy array] x-coordinates in the lookup table</p>
<p>y       [numpy array] y-coordinates in the lookup table</p>
<dl class="docutils">
<dt>val     [numpy array] values at the x and y locations. x, y, and val must be</dt>
<dd>of same size</dd>
</dl>
<p>xin     [numpy array] x-coordinates at which values are required</p>
<dl class="docutils">
<dt>yin     [numpy array] y-coordinates at which values are required. xin and yin</dt>
<dd>must be of same size</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>oob_value</dt>
<dd>[scalar] Value to be returned at the location if the nearest
neighbour for the location is not found inside distance_ULIM.
Default = 0</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
<dt>maxmatch</dt>
<dd>[scalar] A positive value indicating maximum number of input 
locations (xin, yin) to be assigned. Default = None. If set to None, 
all the input locations specified are assigned values. For instance,
to have only one nearest neighbour from the lookup locations to be 
determined per input location, use maxmatch=1.</dd>
<dt>tol     [scalar] If set, only lookup data with abs(val) &gt; tol will be </dt>
<dd>considered for nearest neighbour lookup. Default = None implies all
lookup values will be considered for nearest neighbour determination.
tol is to be interpreted as a minimum value considered as significant
in the lookup table.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple of nearest neighbour lookup value, the index of input
location and nearest neighbour distance in the lookup table. The tuple
consists of the following elements in this order. The number of pairs
matched will be the lesser of those determined by distNN and maxmatch</p>
<dl class="docutils">
<dt>ibind   [numpy vector] indices of the input locations for which nearest </dt>
<dd>neighbours were found from the lookup table. If remove_oob is 
not set to True, size of ibind is equal to size of xin or yin, 
otherwise size of ibind is less than or equal to size of xin or yin. 
Values of ibind equal to size of lookup table values indicates the 
nearest neighbours for the corresponding input location could not be 
found within the distance upper bound from the lookup table. The
corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>nnval   [numpy vector] nearest neighbour lookup values for the given input</dt>
<dd>locations. If remove_oob is not set to True, size of nnval is equal
to size of xin or yin, otherwise size of nnval is less than or equal
to size of xin or yin. In such a case, out of bound locations are
filled with oob_value. Corresponding values in distNN are returned as
inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to size of xin or yin, otherwise size of distNN is 
less than or equal to size of xin or yin. In such a case, out of 
bound locations are filled with inf or NP.inf.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.lookup_1NN">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">lookup_1NN</code><span class="sig-paren">(</span><em>ref</em>, <em>val</em>, <em>inp</em>, <em>distance_ULIM=inf</em>, <em>oob_value=0.0</em>, <em>remove_oob=True</em>, <em>tol=None</em>, <em>maxmatch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#lookup_1NN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.lookup_1NN" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lookup operation based on the first nearest neighbour algorithm 
using KD-Trees when the lookup database and required coordinate locations are
specified.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ref     [numpy array] Reference locations to be looked up to. NxK numpy </dt>
<dd>array which represents N points in K-dimensional coordinates</dd>
<dt>val     [numpy array] values at the x and y locations. x, y, and val must be</dt>
<dd>of same size</dd>
<dt>inp     [numpy array] Input locations for which nearest neighbours will be</dt>
<dd>searched in reference locations specified in ref. MxK numpy array
representing M points in K-dimensional coordinates. Must have same
number of columns as input parameter ref.</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>maxmatch</dt>
<dd>[scalar] A positive value indicating maximum number of input 
locations (xin, yin) to be assigned. Default = None. If set to None, 
all the input locations specified are assigned values. For instance,
to have only one nearest neighbour from the lookup locations to be 
determined per input location, use maxmatch=1.</dd>
<dt>tol     [scalar] If set, only lookup data with abs(val) &gt; tol will be </dt>
<dd>considered for nearest neighbour lookup. Default = None implies all
lookup values will be considered for nearest neighbour determination.
tol is to be interpreted as a minimum value considered as significant
in the lookup table.</dd>
<dt>oob_value</dt>
<dd>[scalar] Value to be returned at the location if the nearest
neighbour for the location is not found inside distance_ULIM.
Default = 0</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple in the following order:
index of input location, nearest neighbour lookup
value, nearest neighbour distance from the lookup table, and the index of the
nearest neighbour in the lookup table. 
The number of pairs matched will be the lesser of those determined by distNN
and maxmatch</p>
<dl class="docutils">
<dt>ibind   [numpy vector] indices of the input locations for which nearest </dt>
<dd>neighbours were found from the lookup table. If remove_oob is 
not set to True, size of ibind is equal to size of xin or yin, 
otherwise size of ibind is less than or equal to size of xin or yin. 
Values of ibind equal to size of lookup table values indicates the 
nearest neighbours for the corresponding input location could not be 
found within the distance upper bound from the lookup table. The
corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>nnval   [numpy vector] nearest neighbour lookup values for the given input</dt>
<dd>locations. If remove_oob is not set to True, size of nnval is equal
to size of xin or yin, otherwise size of nnval is less than or equal
to size of xin or yin. In such a case, out of bound locations are
filled with oob_value. Corresponding values in distNN are returned as
inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to size of xin or yin, otherwise size of distNN is 
less than or equal to size of xin or yin. In such a case, out of 
bound locations are filled with inf or NP.inf.</dd>
<dt>refind  [numpy vector] indices of the nearest neighbours in the reference </dt>
<dd>lookup table. i.e., ref[refind,:] are the nearest neighbours of 
inp[inpind] with distances distNN.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.lookup_1NN_new">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">lookup_1NN_new</code><span class="sig-paren">(</span><em>ngbrin</em>, <em>val</em>, <em>ngbrof</em>, <em>distance_ULIM=inf</em>, <em>oob_value=0.0</em>, <em>remove_oob=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#lookup_1NN_new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.lookup_1NN_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lookup operation based on nearest neighbour algorithm using
KD-Trees when the lookup database and required coordinate locations are
specified.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ngbrin [numpy array] locations of neighbours from which first nearest </dt>
<dd>neighbours of locations in ngbrof must be found. MxK numpy array 
corresponding to M locations specified in K coordinates</dd>
</dl>
<p>val    [numpy array] array of M values at the ngbrin locations</p>
<dl class="docutils">
<dt>ngbrof [numpy array] locations for which neighbours in locations specified</dt>
<dd>by ngbrin must be found. NxK array corresponding to N locations 
specified in K coordinates</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>oob_value</dt>
<dd>[scalar] Value to be returned at the location if the nearest
neighbour for the location is not found inside distance_ULIM.
Default = 0</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple of nearest neighbour lookup value, the index of nearest
neighbour location in the lookup table and nearest neighbour distance in 
the lookup table. The tuple consists of the following elements in this 
order. The number of pairs matched will be the lesser of those determined 
by distNN and the nearest match</p>
<dl class="docutils">
<dt>ibind   [numpy vector] indices of the input locations (ngbrof) for which </dt>
<dd>nearest neighbours were found from the lookup table. If remove_oob is 
not set to True, size of ibind is equal to N (the number of 
locations in ngbrof, otherwise size of ibind is less than or equal 
to N. Values of ibind equal to size of lookup table values indicates 
the nearest neighbours for the corresponding input location could 
not be found within the distance upper bound from the lookup table. 
The corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>nnval   [numpy vector] nearest neighbour lookup values for the given input</dt>
<dd>locations. If remove_oob is not set to True, size of nnval is equal
to N, otherwise size of nnval is less than or equal
to N. In such a case, out of bound locations are
filled with oob_value. Corresponding values in distNN are returned 
as inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to N (number of locations in ngbrof), otherwise 
size of distNN is less than or equal to N. In such 
a case, out of bound locations are filled with inf or NP.inf.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.lookup_1NN_old">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">lookup_1NN_old</code><span class="sig-paren">(</span><em>ref</em>, <em>val</em>, <em>inp</em>, <em>distance_ULIM=inf</em>, <em>oob_value=0.0</em>, <em>remove_oob=True</em>, <em>tol=None</em>, <em>maxmatch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#lookup_1NN_old"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.lookup_1NN_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lookup operation based on the first nearest neighbour algorithm 
using KD-Trees when the lookup database and required coordinate locations are
specified.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ref     [numpy array] Reference locations to be looked up to. NxK numpy </dt>
<dd>array which represents N points in K-dimensional coordinates</dd>
<dt>val     [numpy array] values at the x and y locations. x, y, and val must be</dt>
<dd>of same size</dd>
<dt>inp     [numpy array] Input locations for which nearest neighbours will be</dt>
<dd>searched in reference locations specified in ref. MxK numpy array
representing M points in K-dimensional coordinates. Must have same
number of columns as input parameter ref.</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>maxmatch</dt>
<dd>[scalar] A positive value indicating maximum number of input 
locations (xin, yin) to be assigned. Default = None. If set to None, 
all the input locations specified are assigned values. For instance,
to have only one input location to be populated per antenna, use
maxmatch=1.</dd>
<dt>tol     [scalar] If set, only lookup data with abs(val) &gt; tol will be </dt>
<dd>considered for nearest neighbour lookup. Default = None implies all
lookup values will be considered for nearest neighbour determination.
tol is to be interpreted as a minimum value considered as significant
in the lookup table.</dd>
<dt>oob_value</dt>
<dd>[scalar] Value to be returned at the location if the nearest
neighbour for the location is not found inside distance_ULIM.
Default = 0</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple in the following order:
index of input location, nearest neighbour lookup
value, nearest neighbour distance from the lookup table, and the index of the
nearest neighbour in the lookup table. 
The number of pairs matched will be the lesser of those determined by distNN
and maxmatch</p>
<dl class="docutils">
<dt>ibind   [numpy vector] indices of the input locations for which nearest </dt>
<dd>neighbours were found from the lookup table. If remove_oob is 
not set to True, size of ibind is equal to size of xin or yin, 
otherwise size of ibind is less than or equal to size of xin or yin. 
Values of ibind equal to size of lookup table values indicates the 
nearest neighbours for the corresponding input location could not be 
found within the distance upper bound from the lookup table. The
corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>nnval   [numpy vector] nearest neighbour lookup values for the given input</dt>
<dd>locations. If remove_oob is not set to True, size of nnval is equal
to size of xin or yin, otherwise size of nnval is less than or equal
to size of xin or yin. In such a case, out of bound locations are
filled with oob_value. Corresponding values in distNN are returned as
inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to size of xin or yin, otherwise size of distNN is 
less than or equal to size of xin or yin. In such a case, out of 
bound locations are filled with inf or NP.inf.</dd>
<dt>refind  [numpy vector] indices of the nearest neighbours in the reference </dt>
<dd>lookup table. i.e., ref[refind,:] are the nearest neighbours of 
inp[inpind] with distances distNN.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.lookup_new">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">lookup_new</code><span class="sig-paren">(</span><em>ngbrin</em>, <em>val</em>, <em>ngbrof</em>, <em>distance_ULIM=inf</em>, <em>oob_value=0.0</em>, <em>remove_oob=True</em>, <em>tol=None</em>, <em>maxmatch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#lookup_new"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.lookup_new" title="Permalink to this definition">¶</a></dt>
<dd><p>NEEDS SERIOUS DEVELOPMENT AND TESTING!!!</p>
<p>Perform a lookup operation based on nearest neighbour algorithm using
KD-Trees when the lookup database and required coordinate locations are
specified.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>ngbrin [numpy array] locations of neighbours from which neighbours of </dt>
<dd>locations in ngbrof must be found. MxK numpy array corresponding
to M locations specified in K coordinates</dd>
</dl>
<p>val    [numpy array] array of M values at the ngbrin locations</p>
<dl class="docutils">
<dt>ngbrof [numpy array] locations for which neighbours in locations specified</dt>
<dd>by ngbrin must be found. NxK array corresponding to N locations 
specified in K coordinates</dd>
<dt>distance_ULIM</dt>
<dd>[scalar] A positive number for the upper bound on distance while
searching for nearest neighbours. Neighbours outside of this upper
bound are not searched for. Default = NP.inf (infinite distance upper 
bound means nearest neighbours will be searched all the way out to 
infinite distance). Should be in the same units as x, y, xin and yin</dd>
<dt>oob_value</dt>
<dd>[scalar] Value to be returned at the location if the nearest
neighbour for the location is not found inside distance_ULIM.
Default = 0</dd>
<dt>remove_oob</dt>
<dd>[boolean] If set to True, results of nearest neighbour search and 
lookup are returned only for those input locations which have a 
neighbour within the distance upper bound. Locations with no 
neighbours inside the distance upper bound will not be in the 
returned results. Default = True. If set to False, even if no 
nearest neighbours are found within the distance upper bound, an
infinite distance and out of bound index from the lookup table are
returned.</dd>
<dt>maxmatch</dt>
<dd>[scalar] A positive value indicating maximum number of input 
locations (in ngbrof) to be assigned. Default = None. If set to 
None, only the first nrearest neighbour is searched for and the 
correspoding value assigned. all the input locations specified are 
assigned values. For instance, to have only one nearest neighbour 
from the lookup locations to be determined per input location, use 
maxmatch=1 or maxmatch=None.</dd>
<dt>tol     [scalar] If set, only lookup data with abs(val) &gt; tol will be </dt>
<dd>considered for nearest neighbour lookup. Default = None implies all
lookup values will be considered for nearest neighbour determination.
tol is to be interpreted as a minimum value considered as significant
in the lookup table. Changing tol from default may result in
unpredictable indices especially to the lookup (ngbrin) indices</dd>
</dl>
<p>Outputs:</p>
<p>Returns a tuple of nearest neighbour lookup value, the index of input
location and nearest neighbour distance in the lookup table. The tuple
consists of the following elements in this order. The number of pairs
matched will be the lesser of those determined by distNN and maxmatch</p>
<dl class="docutils">
<dt>ibind   [numpy vector] indices of the input locations (ngbrof) for which </dt>
<dd>nearest neighbours were found from the lookup table. If remove_oob is 
not set to True, size of ibind is equal to N (the number of 
locations in ngbrof, otherwise size of ibind is less than or equal 
to N. Values of ibind equal to size of lookup table values indicates 
the nearest neighbours for the corresponding input location could 
not be found within the distance upper bound from the lookup table. 
The corresponding values in distNN are returned as inf or NP.inf</dd>
<dt>nnval   [numpy vector] nearest neighbour lookup values for the given input</dt>
<dd>locations. If remove_oob is not set to True, size of nnval is equal
to N, otherwise size of nnval is less than or equal
to N. In such a case, out of bound locations are
filled with oob_value. Corresponding values in distNN are returned 
as inf or NP.inf</dd>
<dt>distNN  [numpy vector] distance to the nearest neighbour in the lookup table</dt>
<dd>for the given input locations. If remove_oob is not set to True, size 
of distNN is equal to N (number of locations in ngbrof), otherwise 
size of distNN is less than or equal to N. In such 
a case, out of bound locations are filled with inf or NP.inf.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.lookup_operations.read_lookup">
<code class="descclassname">astroutils.lookup_operations.</code><code class="descname">read_lookup</code><span class="sig-paren">(</span><em>infile</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/lookup_operations.html#read_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.lookup_operations.read_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from a lookup database.</p>
<p>Inputs:</p>
<p>infile  [string] Input file containing the lookup data base.</p>
<p>Outputs:</p>
<dl class="docutils">
<dt>[tuple] each element of the tuple is a numpy array. The elements in order are</dt>
<dd>x-coordinates, y-coordinates, data value at those coordiantes. The
data values are real or complex depending on whether the lookup table
has an &#8216;imag_value&#8217; column</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-astroutils.mathops">
<span id="astroutils-mathops-module"></span><h2>astroutils.mathops module<a class="headerlink" href="#module-astroutils.mathops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.mathops.binned_statistic">
<code class="descclassname">astroutils.mathops.</code><code class="descname">binned_statistic</code><span class="sig-paren">(</span><em>x</em>, <em>values=None</em>, <em>statistic='mean'</em>, <em>bins=10</em>, <em>range=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/mathops.html#binned_statistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.mathops.binned_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Same functionality as binned_statistic() under scipy.stats module but can 
return reverse indices such as in IDL version of histogram. Read the 
documentation on the two aforementioned functions.</p>
<p>Inputs:</p>
<p>x          [numpy vector] A sequence of values to be binned.</p>
<dl class="docutils">
<dt>values     [numpy vector] The values on which the statistic will be computed.</dt>
<dd>This must be the same shape as x.</dd>
<dt>statistic  [string or callable, optional] The statistic to compute (default</dt>
<dd><p class="first">is &#8216;mean&#8217;). The following statistics are available:</p>
<dl class="last docutils">
<dt>&#8216;mean&#8217;</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">compute the mean of values for points within each bin.</span><dd>Empty bins will be represented by NaN.</dd>
<dt>&#8216;median&#8217;</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">compute the median of values for points within each</span><dd>bin. Empty bins will be represented by NaN.</dd>
<dt>&#8216;count&#8217;</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">compute the count of points within each bin. This is</span><dd>identical to an unweighted histogram. values array is
not referenced.</dd>
<dt>&#8216;sum&#8217;</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">compute the sum of values for points within each bin.</span><dd>This is identical to a weighted histogram.</dd>
<dt>function</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a user-defined function which takes a 1D array of</span><dd>values, and outputs a single numerical statistic. This
function will be called on the values in each bin.
Empty bins will be represented by function([]), or NaN
if this returns an error.</dd>
</dl>
</dd>
<dt>bins       [int or sequence of scalars, optional] If bins is an int, it</dt>
<dd>defines the number of equal-width bins in the given range (10, by
default). If bins is a sequence, it defines the bin edges,
including the rightmost edge, allowing for non-uniform bin widths.</dd>
<dt>range      [2-element tuple in list, optional] The lower and upper range of</dt>
<dd>the bins. If not provided, range is simply (x.min(), x.max()).
Values outside the range are ignored.</dd>
<dt>reverse_indices</dt>
<dd>[boolean] If set to True (default), returns the reverse indices
in revind</dd>
</dl>
<p>Outputs:</p>
<p>statistic  [numpy vector] The values of the selected statistic in each bin.</p>
<p>bin_edges  [numpy vector] Return the bin edges (length(statistic)+1).</p>
<dl class="docutils">
<dt>binnumber  [numpy vector] This assigns to each observation an integer that</dt>
<dd>represents the bin in which this observation falls. Array has the
same length as values.</dd>
<dt>revind     [numpy vector] list of reverse indices like the IDL counterpart.</dt>
<dd>Vector whose number of elements is the sum of the number of
elements in the histogram, N, and the number of array elements
included in the histogram, plus one. The subscripts of the
original array elements falling in the ith bin, 0 &lt;= i &lt; N, are
given by the expression: R(R[i] : R[i+1]), where R is the
reverse index list. If R[i] is equal to R[i+1], no elements are
present in the i-th bin.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.mathops.healpix_interp_along_axis">
<code class="descclassname">astroutils.mathops.</code><code class="descname">healpix_interp_along_axis</code><span class="sig-paren">(</span><em>indata</em>, <em>theta_phi=None</em>, <em>inloc_axis=None</em>, <em>outloc_axis=None</em>, <em>axis=-1</em>, <em>kind='linear'</em>, <em>bounds_error=True</em>, <em>fill_value=nan</em>, <em>assume_sorted=False</em>, <em>nest=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/mathops.html#healpix_interp_along_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.mathops.healpix_interp_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate healpix data to specified angular locations (HEALPIX 
interpolation) and along one other specified axis (usually frequency axis, 
for instance) via SciPy interpolation. Wraps HEALPIX and SciPy interpolations
into one routine.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>indata      [numpy array] input data to be interpolated. Must be of shape </dt>
<dd>(nhpy x nax1 x nax2 x ...). Currently works only for 
(nhpy x nax1). nhpy is a HEALPIX compatible npix</dd>
<dt>theta_phi   [numpy array] spherical angle locations (in radians) at which</dt>
<dd>the healpix data is to be interpolated to at each of the other 
given axes. It must be of size nang x 2 where nang is the number 
of spherical angle locations, 2 denotes theta and phi. If set to
None (default), no healpix interpolation is performed</dd>
<dt>inloc_axis  [numpy array] locations along the axis specified in axis (to be </dt>
<dd>interpolated with SciPy) in which indata is specified. It 
should be of size nax1, nax2, ... or naxm. Currently it works 
only if set to nax1</dd>
<dt>outloc_axis [numpy array] locations along the axis specified in axis to be </dt>
<dd>interpolated to with SciPy. The axis over which this 
interpolation is to be done is specified in axis. It must be of
size nout. If this is set exactly equal to inloc_axis, no 
interpolation along this axis is performed</dd>
<dt>axis        [integer] axis along which SciPy interpolation is to be done. </dt>
<dd>If set to -1 (default), the interpolation happens over the last
axis. Since the first axis of indata is reserved for the healpix
pixels, axis must be set to 1 or above (upto indata.ndim-1).</dd>
<dt>kind        [str or int] Specifies the kind of interpolation as a </dt>
<dd>string (&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, 
&#8216;cubic&#8217; where &#8216;slinear&#8217;, &#8216;quadratic&#8217; and &#8216;cubic&#8217; refer to a 
spline interpolation of first, second or third order) or as an 
integer specifying the order of the spline interpolator to use. 
Default is &#8216;linear&#8217;.</dd>
<dt>bounds_error </dt>
<dd>[bool, optional] If True, a ValueError is raised any time 
interpolation is attempted on a value outside of the range of x 
(where extrapolation is necessary). If False, out of bounds 
values are assigned fill_value. By default, an error is raised.</dd>
<dt>fill_value  [float] If provided, then this value will be used to fill in </dt>
<dd>for requested points outside of the data range. If not provided, 
then the default is NaN.</dd>
<dt>assume_sorted </dt>
<dd>[bool] If False, values of inloc_axis can be in any order and 
they are sorted first. If True, inloc_axis has to be an array 
of monotonically increasing values.</dd>
</dl>
<p>nest        [bool] if True, the is assumed to be in NESTED ordering.</p>
<p>Outputs:</p>
<p>HEALPIX interpolated and SciPy interpolated output. Will be of size
nang x ... x nout x ... x naxm. Currently returns an array of shape 
nang x nout
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.mathops.interpolate_array">
<code class="descclassname">astroutils.mathops.</code><code class="descname">interpolate_array</code><span class="sig-paren">(</span><em>inparray</em>, <em>inploc</em>, <em>outloc</em>, <em>axis=-1</em>, <em>kind='linear'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/mathops.html#interpolate_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.mathops.interpolate_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a multi-dimensional array along one of its dimensions. It acts 
as a wrapper to scipy.interpolate.interp1d but applies boundary conditions 
differently</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>inparray    [numpy array] Multi-dimensional input array which will be used </dt>
<dd>in determining the interpolation function</dd>
<dt>inploc      [numpy array] Locations using which the interpolation function</dt>
<dd>is determined. It must be of size equal to the dimension of 
input array along which interpolation is to be determined 
specified by axis keyword input. It must be a list or numpy 
array</dd>
<dt>outloc      [list or numpy array] Locations at which interpolated array is</dt>
<dd>to be determined along the specified axis. It must be a scalar, 
list or numpy array. If any of outloc is outside the range of
inploc, the first and the last cubes from the inparray will
be used as boundary values</dd>
<dt>axis        [scalar] Axis along which interpolation is to be performed. </dt>
<dd>Default=-1 (last axis)</dd>
<dt>kind        [string or integer] Specifies the kind of interpolation as a </dt>
<dd>string (&#8216;linear&#8217;, &#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic&#8217;, 
&#8216;cubic&#8217; where &#8216;slinear&#8217;, &#8216;quadratic&#8217; and &#8216;cubic&#8217; refer to a 
spline interpolation of first, second or third order) or as an 
integer specifying the order of the spline interpolator to use. 
Default is &#8216;linear&#8217;.</dd>
</dl>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.mathops.percentiles_to_2D_contour_levels">
<code class="descclassname">astroutils.mathops.</code><code class="descname">percentiles_to_2D_contour_levels</code><span class="sig-paren">(</span><em>pdf</em>, <em>percentiles</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/mathops.html#percentiles_to_2D_contour_levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.mathops.percentiles_to_2D_contour_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine 2D contour levels given percentiles</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>pdf         [numpy array] 2D array denoting the probability density function</dt>
<dd>from which contour levels for the given percentiles are to be
determined</dd>
<dt>percentiles [list or numpy array] The percentiles (in percent) for which </dt>
<dd>contour levels are to be determined. All elements in this
array must lie between 0 and 100</dd>
<dt>Output:     [numpy array] Contour levels corresponding to the input </dt>
<dd>percentiles. Size of returned array will be equal to that of 
the input percentiles.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.mathops.reverse">
<code class="descclassname">astroutils.mathops.</code><code class="descname">reverse</code><span class="sig-paren">(</span><em>inp</em>, <em>axis=0</em>, <em>ind_range=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/mathops.html#reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.mathops.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic function to reverse a specific axis or a subset of 
indices of this specific axis of a multi-dimensional array. This 
works on data up to 8 dimensions.</p>
<p>Input:</p>
<p>inp        Multi-dimensional array (up to 8 dimensions)</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>axis      [scalar, default = 0] The axis along which the array </dt>
<dd>is to be reversed while preserving the order of the other 
axes. 0 &lt;= axis &lt;= 7</dd>
<dt>ind_range [2-element list] The lower and upper limits of indices</dt>
<dd>of the axis over which the data is to be reversed. Default = None
selects all indices for reversal.</dd>
</dl>
<p>Output:</p>
<p>The array with its data reversed over a subset or the entirety of the
specified axis.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.mathops.rms">
<code class="descclassname">astroutils.mathops.</code><code class="descname">rms</code><span class="sig-paren">(</span><em>inp</em>, <em>axis=None</em>, <em>filter_dict=None</em>, <em>mask=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/mathops.html#rms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.mathops.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the rms of multi-dimensional (complex) input data along an axis (if
specified). Optionally, fourier frequency filtering and masks can be used to
refine the data before estimating rms.</p>
<p>Inputs:</p>
<p>inp         [Numpy array] input data for which RMS has to be estimated.</p>
<p>Keyword Inputs:</p>
<dl class="docutils">
<dt>axis        [scalar integer] Axis over which FFT is performed. Default = None</dt>
<dd>(last axis). Any negative value or values exceeding the number of
axes in the input data will be reset to use the last axis.</dd>
<dt>filter_dict [dictionary] Filter parameters in the Fourier (frequency) domain.</dt>
<dd><p class="first">Default is None (no filtering to be applied). If set, the
filtering will be applied along the specified axis. If axis is
not specified, no frequency domain filtering will be applied. 
This is a dictionary consisting of the following keys and info:
&#8216;freqwts&#8217;    [Numpy array] frequency window of weights. Should</p>
<blockquote>
<div>either have same shape as inp or have number of
elements equal to the number of elements in input
data along specified axis. Default = None.
If not set, then it will be set to a rectangular
window of width specified by key &#8216;width&#8217; (see below) 
and will be applied as a filter identically to the
entire data along the specified axis.</div></blockquote>
<dl class="last docutils">
<dt>&#8216;width&#8217;      [scalar] Width of the frequency window as a fraction </dt>
<dd>of the bandwidth. Has to be positive. Default is
None. If width is None, wts should be set. One and
only one among wts and width should be set.</dd>
<dt>&#8216;passband&#8217;   [string scalar] String specifying the passband</dt>
<dd>(&#8216;low&#8217; or &#8216;high&#8217;) to be used. Default = &#8216;low&#8217;.</dd>
</dl>
</dd>
<dt>mask        [Numpy array] Numpy array with same dimensions as the input </dt>
<dd>data. The values can be Boolean or can be integers which in turn
will be converted to Boolean values. Mask values with True will 
be masked and ignored in the rms estimates while mask values with
False will only be considered in obtaining the rms estimates. 
Default = None (no masking to be applied)</dd>
<dt>verbose     [boolean] If set to True (default), print messages indicating</dt>
<dd>progress</dd>
</dl>
<p>Output:</p>
<p>RMS estimate of the input data. If the input data is complex, the output 
consists of rms estimate of the real and imaginary parts of the data after
applying the specified filtering and/or masking.
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
</dd></dl>

</div>
<div class="section" id="module-astroutils.nonmathops">
<span id="astroutils-nonmathops-module"></span><h2>astroutils.nonmathops module<a class="headerlink" href="#module-astroutils.nonmathops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="astroutils.nonmathops.find_all_occurrences_list1_in_list2">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">find_all_occurrences_list1_in_list2</code><span class="sig-paren">(</span><em>list1</em>, <em>list2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#find_all_occurrences_list1_in_list2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.find_all_occurrences_list1_in_list2" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all occurrences of input list1 (a reference list) in input list2</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>list1   [list or numpy array] List of elements which need to be searched </dt>
<dd>for in list2. Must be a flattened list or numpy array</dd>
<dt>list2   [list or numpy array] List of elements in which elements in list1 </dt>
<dd>are searched for. Must be a flattened list or numpy array</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>ind     [list of lists] Indices of occurrences of elements </dt>
<dd>of input list1 indexed into list2. For each element in list1, 
there is an output list which contains all the indices of this 
element occurring in list2. Hence, the output is a list of lists
where the top level list contains equal number of items as list1.
Each i-th item in this list is another list containing indices of 
the element list1[i] in list2</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.find_list_in_list">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">find_list_in_list</code><span class="sig-paren">(</span><em>reference_array</em>, <em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#find_list_in_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.find_list_in_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Find occurrences of input list in a reference list and return indices 
into the reference list</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>reference_array [list or numpy array] One-dimensional reference list or</dt>
<dd>numpy array in which occurrences of elements in the input 
list or array will be found</dd>
<dt>inp             [list or numpy array] One-dimensional input list whose </dt>
<dd>elements will be searched in the reference array and 
the indices into the reference array will be returned</dd>
</dl>
<p>Output:</p>
<dl class="docutils">
<dt>ind             [numpy masked array] Indices of occurrences of elements </dt>
<dd>of input array in the reference array. It will be of same 
size as input array. For example, 
inp = reference_array[ind]. Indices for elements which are 
not found in the reference array will be masked.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.is_dict1_subset_of_dict2">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">is_dict1_subset_of_dict2</code><span class="sig-paren">(</span><em>dict1</em>, <em>dict2</em>, <em>ignoreNone=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#is_dict1_subset_of_dict2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.is_dict1_subset_of_dict2" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if keys and values of the first dictionary are a subset of the second.</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>dict1       [dictionary] First dictionary. It will be checked if both its</dt>
<dd>keys and values are a subset of the second dictionary.</dd>
<dt>dict2       [dictionary] Second dictionary. The values and keys of the first</dt>
<dd>dictionary will be checked against this dictionary to check if
the first is a subset of the second.</dd>
<dt>ignoreNone  [boolean] If set to True (default), the subset checking happens</dt>
<dd>using the non-None values in both dictionaries. This is a 
loose check. If set to False, a strict subset checking happens
not ignoring the None values, if any.</dd>
</dl>
<p>Output:</p>
<p>Boolean value True if dict1 is found to be a subset of dict2, False 
otherwise
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.load_dict_from_hdf5">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">load_dict_from_hdf5</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#load_dict_from_hdf5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.load_dict_from_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Load HDF5 contents into a python dictionary preserving the structure</p>
<p>Input:</p>
<p>filename    [string] Full path to the HDF5 file</p>
<p>Output:</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.recursive_find_notNone_in_dict">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">recursive_find_notNone_in_dict</code><span class="sig-paren">(</span><em>inpdict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#recursive_find_notNone_in_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.recursive_find_notNone_in_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively walk through a dictionary and reduce it to only non-None values.</p>
<p>Inputs:</p>
<p>inpdict     [dictionary] Input dictionary to reduced to non-None values</p>
<p>Outputs:</p>
<p>outdict is an output dictionary which only contains keys and values 
corresponding to non-None values
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.recursively_load_dict_contents_from_group">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">recursively_load_dict_contents_from_group</code><span class="sig-paren">(</span><em>h5file</em>, <em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#recursively_load_dict_contents_from_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.recursively_load_dict_contents_from_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively load HDF5 group contents into python dictionary structure</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>h5file      [Python File Object] An open file object under which the HDF5</dt>
<dd>groups will be created</dd>
<dt>path        [string] String containing the root group under the python file</dt>
<dd>object h5file</dd>
</dl>
<p>Output:</p>
<p>Python structure that is copied from the HDF5 content at the level 
specified by the path in the python object h5file
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.recursively_save_dict_contents_to_group">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">recursively_save_dict_contents_to_group</code><span class="sig-paren">(</span><em>h5file</em>, <em>path</em>, <em>dic</em>, <em>compressinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#recursively_save_dict_contents_to_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.recursively_save_dict_contents_to_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively store contents of a dictionary in HDF5 groups</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>h5file      [Python File Object] An open file object under which the HDF5</dt>
<dd>groups will be created</dd>
<dt>path        [string] String containing the root group under the python file</dt>
<dd>object h5file</dd>
<dt>dic         [dictionary] dictionary whose keys and items will be stored </dt>
<dd>under the root group specified by path under the python file
object h5file</dd>
<dt>compressinfo</dt>
<dd><p class="first">[dictionary] Dictionary containing compression options or 
set as None (default) when no compression is to be applied. 
When compression is to be applied, it contains keys of those 
data that are to be compressed. Under each key is another 
dictionary with the following keys and values:
&#8216;compress_fmt&#8217;  [string] Compression format. Accepted values</p>
<blockquote>
<div>are &#8216;gzip&#8217; and &#8216;lzf&#8217;</div></blockquote>
<dl class="docutils">
<dt>&#8216;compress_opts&#8217; [int] Integer denoting level of compression. </dt>
<dd>Only applies if compress_fmt is set to &#8216;gzip&#8217;.
It must be an integer between 0 and 9</dd>
<dt>&#8216;chunkshape&#8217;    [tuple] Shape of the chunks to be used in </dt>
<dd>compression. It must be broadcastable to the
data shape inside input dic</dd>
</dl>
<p class="last">If at any point, any error is encountered, it will switch to 
no compression</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="astroutils.nonmathops.save_dict_to_hdf5">
<code class="descclassname">astroutils.nonmathops.</code><code class="descname">save_dict_to_hdf5</code><span class="sig-paren">(</span><em>dic</em>, <em>filename</em>, <em>compressinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/nonmathops.html#save_dict_to_hdf5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.nonmathops.save_dict_to_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a dictionary as a HDF5 structure under the given filename preserving 
its structure</p>
<p>Inputs:</p>
<dl class="docutils">
<dt>dic         [dictionary] Input dictionary which is to be stored in HDF5</dt>
<dd>format</dd>
<dt>filename    [string] string containing full path to the HDF5 file including </dt>
<dd>the file name</dd>
<dt>compressinfo</dt>
<dd><p class="first">[dictionary] Dictionary containing compression options or 
set as None (default) when no compression is to be applied. 
When compression is to be applied, it contains keys of those 
data that are to be compressed. Under each key is another 
dictionary with the following keys and values:
&#8216;compress_fmt&#8217;  [string] Compression format. Accepted values</p>
<blockquote>
<div>are &#8216;gzip&#8217; and &#8216;lzf&#8217;</div></blockquote>
<dl class="docutils">
<dt>&#8216;compress_opts&#8217; [int] Integer denoting level of compression. </dt>
<dd>Only applies if compress_fmt is set to &#8216;gzip&#8217;.
It must be an integer between 0 and 9</dd>
<dt>&#8216;chunkshape&#8217;    [tuple] Shape of the chunks to be used in </dt>
<dd>compression. It must be broadcastable to the
data shape inside input dic</dd>
</dl>
<p class="last">If at any point, any error is encountered, it will switch to 
no compression</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-astroutils.writer_module">
<span id="astroutils-writer-module-module"></span><h2>astroutils.writer_module module<a class="headerlink" href="#module-astroutils.writer_module" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="astroutils.writer_module.Writer">
<em class="property">class </em><code class="descclassname">astroutils.writer_module.</code><code class="descname">Writer</code><span class="sig-paren">(</span><em>location</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/writer_module.html#Writer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.writer_module.Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Create an object with a write method that writes to a
specific place on the screen, defined at instantiation.</p>
<dl class="method">
<dt id="astroutils.writer_module.Writer.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/astroutils/writer_module.html#Writer.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#astroutils.writer_module.Writer.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-astroutils">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-astroutils" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">astroutils package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-astroutils.DSP_modules">astroutils.DSP_modules module</a></li>
<li><a class="reference internal" href="#module-astroutils.MPI_modules">astroutils.MPI_modules module</a></li>
<li><a class="reference internal" href="#module-astroutils.catalog">astroutils.catalog module</a></li>
<li><a class="reference internal" href="#module-astroutils.constants">astroutils.constants module</a></li>
<li><a class="reference internal" href="#module-astroutils.cosmotile">astroutils.cosmotile module</a></li>
<li><a class="reference internal" href="#module-astroutils.ephemeris_timing">astroutils.ephemeris_timing module</a></li>
<li><a class="reference internal" href="#module-astroutils.foregrounds">astroutils.foregrounds module</a></li>
<li><a class="reference internal" href="#module-astroutils.geometry">astroutils.geometry module</a></li>
<li><a class="reference internal" href="#module-astroutils.gridding_modules">astroutils.gridding_modules module</a></li>
<li><a class="reference internal" href="#module-astroutils.kernel_density_estimator">astroutils.kernel_density_estimator module</a></li>
<li><a class="reference internal" href="#module-astroutils.lookup_operations">astroutils.lookup_operations module</a></li>
<li><a class="reference internal" href="#module-astroutils.mathops">astroutils.mathops module</a></li>
<li><a class="reference internal" href="#module-astroutils.nonmathops">astroutils.nonmathops module</a></li>
<li><a class="reference internal" href="#module-astroutils.writer_module">astroutils.writer_module module</a></li>
<li><a class="reference internal" href="#module-astroutils">Module contents</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/astroutils.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Nithyanandan Thyagarajan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/astroutils.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>